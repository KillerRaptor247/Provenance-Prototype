{"version":3,"file":"trrackvis.umd.production.min.js","sources":["../src/Utils/findBundleParent.ts","../src/Utils/translate.ts","../src/components/Styles.ts","../src/components/BackboneNode.tsx","../src/components/BookmarkNode.tsx","../src/components/BookmarkListView.tsx","../src/components/BookmarkTransitions.tsx","../src/components/LinkTransitions.ts","../src/components/Link.tsx","../src/components/UndoRedoButton.tsx","../src/components/ProvVis.tsx","../src/Utils/TreeLayout.ts","../src/components/NodeTransitions.ts","../src/components/BundleTransitions.tsx","../src/components/ProvVisCreator.tsx"],"sourcesContent":["import { BundleMap } from './BundleMap';\n\nexport default function findBundleParent(\n  nodeId: string,\n  bundleMap?: BundleMap\n): string[] {\n  const parentList = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const bundle in bundleMap) {\n    if (bundleMap[bundle].bunchedNodes.includes(nodeId)) {\n      parentList.push(bundle);\n    }\n  }\n\n  return parentList;\n}\n","export default function translate(x: number, y: number) {\n  return `translate(${x}, ${y})`;\n}\n","import { style } from 'typestyle';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const treeColor = (current?: boolean) =>\n  style({\n    fill: current ? 'rgb(33, 133, 208)' : 'white',\n    stroke: 'rgb(33, 133, 208)',\n  });\n","/* eslint-disable no-unused-vars */\nimport { Provenance, ProvenanceNode, StateNode } from '@visdesignlab/trrack';\nimport React, { ReactChild, useState } from 'react';\nimport { Animate } from 'react-move';\nimport { Popup } from 'semantic-ui-react';\nimport { BundleMap } from '../Utils/BundleMap';\nimport { EventConfig } from '../Utils/EventConfig';\nimport translate from '../Utils/translate';\nimport { treeColor } from './Styles';\n\ninterface BackboneNodeProps<T, S extends string, A> {\n  prov: Provenance<T, S, A>;\n  first: boolean;\n  iconOnly: boolean;\n  current: boolean;\n  duration: number;\n  node: StateNode<S, A>;\n  radius: number;\n  strokeWidth: number;\n  textSize: number;\n  setBookmark: any;\n  bookmark: any;\n  nodeMap: any;\n  annotationOpen: number;\n  setAnnotationOpen: any;\n  exemptList: string[];\n  setExemptList: any;\n  bundleMap?: BundleMap;\n  clusterLabels: boolean;\n  editAnnotations: boolean;\n  eventConfig?: EventConfig<S>;\n  popupContent?: (nodeId: StateNode<S, A>) => ReactChild;\n  annotationContent?: (nodeId: StateNode<S, A>) => ReactChild;\n  expandedClusterList?: string[];\n}\n\nfunction BackboneNode<T, S extends string, A>({\n  prov,\n  first,\n  iconOnly,\n  current,\n  node,\n  duration,\n  radius,\n  strokeWidth,\n  textSize,\n  nodeMap,\n  annotationOpen,\n  bookmark,\n  setAnnotationOpen,\n  exemptList,\n  setExemptList,\n  bundleMap,\n  eventConfig,\n  popupContent,\n  editAnnotations,\n  annotationContent,\n  expandedClusterList,\n}: BackboneNodeProps<T, S, A>) {\n  const padding = 15;\n\n  const cursorStyle = {\n    cursor: 'pointer',\n  } as React.CSSProperties;\n\n  const [annotateText, setAnnotateText] = useState(\n    prov.getLatestAnnotation(node.id)?.annotation\n      ? prov.getLatestAnnotation(node.id)?.annotation!\n      : ''\n  );\n\n  const handleCheck = () => {\n    const lastAnnotation = prov.getLatestAnnotation(node.id);\n\n    if (lastAnnotation?.annotation !== annotateText.trim()) {\n      prov.addAnnotation(annotateText, node.id);\n      setAnnotationOpen(-1);\n    }\n  };\n\n  const handleClose = () => {\n    setAnnotateText(prov.getLatestAnnotation(node.id)?.annotation!);\n    setAnnotationOpen(-1);\n  };\n\n  const handleInputChange = () => {};\n\n  // console.log(JSON.parse(JSON.stringify(node)));\n  let glyph = (\n    <circle\n      style={cursorStyle}\n      className={treeColor(current)}\n      r={radius}\n      strokeWidth={strokeWidth}\n    />\n  );\n\n  // let backboneBundleNodes = findBackboneBundleNodes(nodeMap, bundleMap)\n\n  let dropDownAdded = false;\n\n  if (eventConfig) {\n    const { eventType } = node.metadata;\n    if (eventType && eventType in eventConfig && eventType !== 'Root') {\n      const { bundleGlyph, currentGlyph, backboneGlyph } = eventConfig[\n        eventType\n      ];\n      if (bundleMap && Object.keys(bundleMap).includes(node.id)) {\n        dropDownAdded = true;\n        glyph = (\n          <g style={cursorStyle} fontWeight={'none'}>\n            {bundleGlyph}\n          </g>\n        );\n      }\n      if (current) {\n        glyph = (\n          <g style={cursorStyle} fontWeight={'none'}>\n            {currentGlyph}\n          </g>\n        );\n      } else if (!dropDownAdded) {\n        glyph = (\n          <g style={cursorStyle} fontWeight={'none'}>\n            {backboneGlyph}\n          </g>\n        );\n      }\n    }\n  }\n\n  let label = '';\n  let annotate = '';\n\n  // console.log(bundleMap)\n  // console.log(nodeMap[node.id]);\n\n  if (\n    bundleMap &&\n    Object.keys(bundleMap).includes(node.id) &&\n    node.actionType === 'Ephemeral' &&\n    expandedClusterList &&\n    !expandedClusterList.includes(node.id)\n  ) {\n    if (node.metadata && node.metadata.eventType) {\n      label = `[${bundleMap[node.id].bunchedNodes.length}] ${\n        node.metadata.eventType\n      }`;\n    } else {\n      label = `[${bundleMap[node.id].bunchedNodes.length}]`;\n    }\n  } else {\n    label = node.label;\n  }\n\n  if (\n    node.artifacts &&\n    node.artifacts.annotations.length > 0 &&\n    annotationOpen !== nodeMap[node.id].depth\n  ) {\n    annotate = node.artifacts.annotations[0].annotation;\n  }\n\n  if (!nodeMap[node.id]) {\n    return null;\n  }\n\n  if (annotate.length > 20) annotate = `${annotate.substr(0, 20)}..`;\n\n  if (label.length > 20) label = `${label.substr(0, 20)}..`;\n\n  const labelG = (\n    <g style={{ opacity: 1 }} transform={translate(padding, 0)}>\n      {!iconOnly ? (\n        <g>\n          {dropDownAdded ? (\n            <text\n              style={cursorStyle}\n              onClick={(e) => nodeClicked(node, e)}\n              fontSize={17}\n              fill={'rgb(248, 191, 132)'}\n              textAnchor=\"middle\"\n              alignmentBaseline=\"middle\"\n              x={1}\n              y={0}\n              fontFamily=\"Icons\"\n            >\n              {expandedClusterList && expandedClusterList.includes(node.id)\n                ? '\\uf0d8'\n                : '\\uf0d7'}\n            </text>\n          ) : (\n            <g></g>\n          )}\n          {editAnnotations ? (\n            <button>\n              <i className=\"fas fa-undo marginRight\"></i>\n              Undo\n            </button>\n          ) : (\n            <g></g>\n          )}\n          <text\n            y={annotate.length === 0 ? 0 : -7}\n            x={dropDownAdded ? 10 : 0}\n            dominantBaseline=\"middle\"\n            textAnchor=\"start\"\n            fontSize={textSize}\n            fontWeight={'bold'}\n            onClick={() => labelClicked(node)}\n          >\n            {label}\n          </text>\n          ,\n          <text\n            y={7}\n            x={dropDownAdded ? 10 : 0}\n            dominantBaseline=\"middle\"\n            textAnchor=\"start\"\n            fontSize={textSize}\n            fontWeight={'regular'}\n            onClick={() => labelClicked(node)}\n          >\n            {annotate}\n          </text>\n          ,\n          <text\n            style={cursorStyle}\n            onClick={(e) => {\n              prov.setBookmark(node.id, !prov.getBookmark(node.id));\n\n              e.stopPropagation();\n            }}\n            fontSize={17}\n            className=\"fas fa\"\n            opacity={bookmark === node.id || prov.getBookmark(node.id) ? 1 : 0}\n            fill={prov.getBookmark(node.id) ? '#2185d0' : '#cccccc'}\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n            x={175}\n            y={0}\n            fontFamily=\"Icons\"\n          >\n            {'\\uf02e'}\n          </text>\n          ,\n          <text\n            style={cursorStyle}\n            onClick={() => {\n              if (\n                annotationOpen === -1 ||\n                nodeMap[node.id].depth !== annotationOpen\n              ) {\n                setAnnotationOpen(nodeMap[node.id].depth);\n              } else {\n                setAnnotationOpen(-1);\n              }\n            }}\n            fontSize={17}\n            opacity={\n              bookmark === node.id || annotationOpen === nodeMap[node.id].depth\n                ? 1\n                : 0\n            }\n            fill={\n              annotationOpen === nodeMap[node.id].depth ? '#2185d0' : '#cccccc'\n            }\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n            x={210}\n            y={0}\n            fontFamily=\"Icons\"\n          >\n            {'\\uf044'}\n          </text>\n        </g>\n      ) : (\n        <g>\n          {dropDownAdded ? (\n            <text\n              style={cursorStyle}\n              onClick={(e) => nodeClicked(node, e)}\n              fontSize={17}\n              fill={'rgb(248, 191, 132)'}\n              textAnchor=\"middle\"\n              alignmentBaseline=\"middle\"\n              x={1}\n              y={0}\n              fontFamily=\"Icons\"\n            >\n              {expandedClusterList && expandedClusterList.includes(node.id)\n                ? '\\uf0d8'\n                : '\\uf0d7'}\n            </text>\n          ) : (\n            <g></g>\n          )}\n        </g>\n      )}\n    </g>\n  );\n\n  return (\n    <Animate\n      start={{ opacity: 0 }}\n      enter={{\n        opacity: [1],\n        timing: { duration: 100, delay: first ? 0 : duration },\n      }}\n    >\n      {() => (\n        <>\n          {popupContent !== undefined && nodeMap[node.id].depth > 0 ? (\n            <Popup content={popupContent(node)} trigger={glyph} />\n          ) : (\n            glyph\n          )}\n          {/* {glyph} */}\n\n          {popupContent !== undefined && nodeMap[node.id].depth > 0 ? (\n            <Popup content={popupContent(node)} trigger={labelG} />\n          ) : (\n            labelG\n          )}\n\n          {annotationOpen !== -1 &&\n          nodeMap[node.id].depth === annotationOpen ? (\n            <g transform=\"translate(15, 25)\">\n              <foreignObject width=\"175\" height=\"80\" x=\"0\" y=\"0\">\n                <div>\n                  <textarea\n                    style={{ maxWidth: 130, resize: 'none' }}\n                    onChange={handleInputChange}\n                    value={annotateText}\n                  />\n                  <button onClick={handleCheck}>Annotate</button>\n\n                  <button onClick={handleClose}>Close</button>\n                </div>\n\n                {/* <Input size='massive' icon='close' onChange={handleInputChange}\n                  defaultValue={annotateText.current} placeholder=\"Edit Annotation\" action>\n                    <input />\n                    <Button color=\"green\" type=\"submit\" onClick={handleCheck}>\n                      <Icon name=\"world\"/>\n                    </Button>\n                    <Button color=\"red\" type=\"submit\" onClick={handleClose}>\n                      <Icon name=\"close\"/>\n                    </Button>\n                  </Input> */}\n              </foreignObject>\n            </g>\n          ) : (\n            <g></g>\n          )}\n        </>\n      )}\n    </Animate>\n  );\n\n  function labelClicked(innerNode: ProvenanceNode<S, A>) {\n    if (annotationOpen === nodeMap[innerNode.id].depth && annotationContent) {\n      setAnnotationOpen(-1);\n    } else if (annotationContent) {\n      setAnnotationOpen(nodeMap[innerNode.id].depth);\n    }\n  }\n\n  function nodeClicked(innerNode: ProvenanceNode<S, A>, event: any) {\n    if (bundleMap && Object.keys(bundleMap).includes(innerNode.id)) {\n      const exemptCopy: string[] = Array.from(exemptList);\n\n      if (exemptCopy.includes(innerNode.id)) {\n        exemptCopy.splice(\n          exemptCopy.findIndex((d) => d === innerNode.id),\n          1\n        );\n      } else {\n        exemptCopy.push(innerNode.id);\n      }\n\n      setExemptList(exemptCopy);\n    }\n\n    event.stopPropagation();\n  }\n}\n\nexport default BackboneNode;\n\n// const Label: FC<{ label: string } & React.SVGProps<SVGTextElement>> = (props: {\n//   label: string;\n// }) => {\n//   return <text {...props}>{props.label}</text>;\n// };\n","import { StateNode } from '@visdesignlab/trrack';\nimport React from 'react';\nimport { Animate } from 'react-move';\nimport { EventConfig } from '../Utils/EventConfig';\nimport { treeColor } from './Styles';\n\ninterface BookmarkNodeProps<T, S extends string, A> {\n  current: boolean;\n  node: StateNode<S, A>;\n  nodeMap: any;\n  editAnnotations: boolean;\n  eventConfig?: EventConfig<S>;\n}\n\nfunction BookmarkNode<T, S extends string, A>({\n  current,\n  node,\n  eventConfig,\n}: BookmarkNodeProps<T, S, A>) {\n  const radius = 5;\n  const strokeWidth = 2;\n  const textSize = 15;\n\n  const cursorStyle = {\n    cursor: 'pointer',\n  } as React.CSSProperties;\n\n  let glyph = (\n    <circle\n      style={cursorStyle}\n      className={treeColor(current)}\n      r={radius}\n      strokeWidth={strokeWidth}\n    />\n  );\n\n  const dropDownAdded = false;\n  const { eventType } = node.metadata;\n\n  if (eventConfig) {\n    const { currentGlyph, backboneGlyph } = eventConfig[eventType];\n\n    if (current) {\n      glyph = (\n        <g style={cursorStyle} fontWeight={'none'}>\n          {currentGlyph}\n        </g>\n      );\n    } else {\n      glyph = (\n        <g style={cursorStyle} fontWeight={'none'}>\n          {backboneGlyph}\n        </g>\n      );\n    }\n  }\n\n  let label = '';\n  let annotate = '';\n\n  if (\n    node.artifacts &&\n    node.artifacts.annotations.length > 0 &&\n    node.artifacts.annotations[0].annotation.length > 0\n  ) {\n    annotate = node.artifacts.annotations[0].annotation;\n  }\n\n  label = node.label;\n\n  if (annotate.length > 20) annotate = `${annotate.substr(0, 20)}..`;\n\n  if (label.length > 20) label = `${label.substr(0, 20)}..`;\n\n  return (\n    <Animate\n      start={{ opacity: 0 }}\n      enter={{\n        opacity: [1],\n      }}\n    >\n      {() => (\n        <>\n          <g style={{ opacity: 1 }}>\n            {glyph}\n\n            <text\n              y={0}\n              x={20}\n              dominantBaseline=\"middle\"\n              textAnchor=\"start\"\n              fontSize={textSize}\n              fontWeight={'bold'}\n            >\n              {label}\n            </text>\n\n            <text\n              y={20}\n              x={dropDownAdded ? 10 : 0}\n              dominantBaseline=\"middle\"\n              textAnchor=\"start\"\n              fontSize={textSize}\n              fontWeight={'regular'}\n            >\n              {annotate}\n            </text>\n          </g>\n        </>\n      )}\n    </Animate>\n  );\n}\n\nexport default BookmarkNode;\n","import { NodeID, ProvenanceGraph } from '@visdesignlab/trrack';\nimport React from 'react';\nimport { NodeGroup } from 'react-move';\nimport { EventConfig } from '../Utils/EventConfig';\nimport translate from '../Utils/translate';\nimport BookmarkNode from './BookmarkNode';\nimport BookmarkTransitions from './BookmarkTransitions';\n\nexport interface BookmarkListViewConfig<T, S extends string, A> {\n  graph?: ProvenanceGraph<S, A>;\n  eventConfig?: EventConfig<S>;\n  currentNode: NodeID;\n}\n\nfunction BookmarkListView<T, S extends string, A>({\n  graph,\n  eventConfig,\n  currentNode,\n}: BookmarkListViewConfig<T, S, A>) {\n  if (graph === undefined) {\n    return null;\n  }\n\n  const gutter = 15;\n  const verticalSpace = 50;\n\n  const bookmarks = [];\n\n  const xOffset = gutter;\n  const yOffset = verticalSpace;\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const j in graph.nodes) {\n    if (graph.nodes[j].bookmarked) {\n      bookmarks.push(graph.nodes[j]);\n    }\n  }\n\n  return (\n    <NodeGroup\n      data={bookmarks}\n      keyAccessor={(d) => d.label}\n      {...BookmarkTransitions(xOffset, yOffset, bookmarks)}\n    >\n      {(innerBookmarks) => (\n        <>\n          {innerBookmarks.map((bookmark) => {\n            const { data: d, key, state } = bookmark;\n\n            return (\n              <g key={key} transform={translate(state.x, state.y)}>\n                <BookmarkNode\n                  current={currentNode === d.id}\n                  node={d}\n                  nodeMap={innerBookmarks}\n                  editAnnotations={false}\n                  eventConfig={eventConfig}\n                />\n              </g>\n            );\n          })}\n        </>\n      )}\n    </NodeGroup>\n  );\n}\n\nexport default BookmarkListView;\n","/* eslint-disable no-plusplus */\nexport default function BookmarkTransitions(\n  xOffset: number,\n  yOffset: number,\n  nodeList: any[]\n) {\n  xOffset = -xOffset;\n\n  const start = (data: any) => {\n    const index = nodeList.findIndex(d => d.id === data.id);\n\n    const x = 0;\n    const y = 40 * index;\n\n    return { x, y: y - yOffset, opacity: 0 };\n  };\n\n  const enter = (data: any) => {\n    const index = nodeList.findIndex(d => d.id === data.id);\n\n    const x = 0;\n    const y = 40 * index;\n\n    return {\n      x: [x],\n      y: [y],\n      opactiy: 1,\n    };\n  };\n\n  const update = (data: any) => {\n    const index = nodeList.findIndex(d => d.id === data.id);\n\n    const x = 0;\n    const y = 40 * index;\n\n    return {\n      x: [x],\n      y: [y],\n      opactiy: 1,\n    };\n  };\n\n  return {\n    enter,\n    leave: start,\n    update,\n    start,\n  };\n}\n","export default function linkTransitions(\n  xOffset: number,\n  yOffset: number,\n  clusterOffset: number,\n  backboneOffset: number,\n  duration = 500,\n  annotationOpen: number,\n  annotationHeight: number\n) {\n  xOffset = -xOffset;\n  backboneOffset = -backboneOffset;\n  const start = () => ({\n    x1: 0,\n    x2: 0,\n    y1: 0,\n    y2: 0,\n    opacity: 0,\n  });\n\n  const enter = (data: any) => {\n    let clusteredNodesInFront = 0;\n\n    // eslint-disable-next-line max-len\n    clusteredNodesInFront =\n      clusteredNodesInFront === 0\n        ? clusteredNodesInFront\n        : clusteredNodesInFront - 1;\n\n    const { source, target } = data;\n    const x1 = getX(source.width, xOffset, backboneOffset);\n    const x2 = getX(target.width, xOffset, backboneOffset);\n\n    let y1 =\n      yOffset * source.depth -\n      (yOffset - clusterOffset) * clusteredNodesInFront;\n    let y2 =\n      yOffset * target.depth -\n      (yOffset - clusterOffset) * clusteredNodesInFront;\n\n    if (\n      annotationOpen !== -1 &&\n      source.depth > annotationOpen &&\n      source.width === 0\n    ) {\n      y1 += annotationHeight;\n    }\n\n    if (\n      annotationOpen !== -1 &&\n      target.depth > annotationOpen &&\n      target.width === 0\n    ) {\n      y2 += annotationHeight;\n    }\n\n    return {\n      x1,\n      x2,\n      y1,\n      y2,\n      opacity: 1,\n      timing: { duration },\n    };\n  };\n\n  const update = (data: any) => {\n    let clusteredNodesInFront = 0;\n\n    // eslint-disable-next-line max-len\n    clusteredNodesInFront =\n      clusteredNodesInFront === 0\n        ? clusteredNodesInFront\n        : clusteredNodesInFront - 1;\n\n    const { source, target } = data;\n    const x1 = getX(source.width, xOffset, backboneOffset);\n    const x2 = getX(target.width, xOffset, backboneOffset);\n\n    let y1 =\n      yOffset * source.depth -\n      (yOffset - clusterOffset) * clusteredNodesInFront;\n    let y2 =\n      yOffset * target.depth -\n      (yOffset - clusterOffset) * clusteredNodesInFront;\n\n    if (\n      annotationOpen !== -1 &&\n      source.depth > annotationOpen &&\n      source.width === 0\n    ) {\n      y1 += annotationHeight;\n    }\n\n    if (\n      annotationOpen !== -1 &&\n      target.depth > annotationOpen &&\n      target.width === 0\n    ) {\n      y2 += annotationHeight;\n    }\n\n    return {\n      x1: [x1],\n      y1: [y1],\n      x2: [x2],\n      y2: [y2],\n      opacity: 1,\n      timing: { duration },\n    };\n  };\n\n  return {\n    enter,\n    leave: start,\n    update,\n    start,\n  };\n}\n\nexport function getX(width: number, xOffset: number, backboneOffset: number) {\n  return width > 1\n    ? (xOffset + backboneOffset) * width - backboneOffset\n    : (xOffset + backboneOffset) * width;\n}\n","import React, { FC } from 'react';\n\ntype LinkProps = {} & React.SVGProps<SVGLineElement>;\n\nconst Link: FC<LinkProps> = (props: LinkProps) => <line {...props} />;\n\nexport default Link;\n","import { ProvenanceGraph } from '@visdesignlab/trrack';\nimport React from 'react';\nimport { Button } from 'semantic-ui-react';\nimport { style } from 'typestyle';\n\nexport interface UndoRedoConfig<T, S extends string, A> {\n  undoCallback: () => void;\n  redoCallback: () => void;\n  graph?: ProvenanceGraph<S, A>;\n}\n\nfunction UndoRedoButton<T, S extends string, A>({\n  graph,\n  undoCallback,\n  redoCallback,\n}: UndoRedoConfig<T, S, A>) {\n  if (graph === undefined) {\n    return null;\n  }\n\n  const isAtRoot = graph.root === graph.current;\n  const isAtLatest = graph.nodes[graph.current].children.length === 0;\n\n  const margin = {\n    marginRight: '3px',\n  } as React.CSSProperties;\n\n  return (\n    <div>\n      <Button\n        variant=\"outlined\"\n        className={undoButtonStyle}\n        disabled={isAtRoot}\n        onClick={undoCallback}\n      >\n        <i style={margin} className=\"fas fa-undo marginRight\"></i>\n        Undo\n      </Button>\n\n      <Button\n        variant=\"outlined\"\n        className={redoButtonStyle}\n        disabled={isAtLatest}\n        onClick={redoCallback}\n      >\n        <i style={margin} className=\"fas fa-redo marginRight\"></i>\n        Redo\n      </Button>\n    </div>\n  );\n}\n\nconst undoButtonStyle = style({\n  marginTop: '2px',\n  borderRadius: '2px',\n  display: 'inline-block',\n  cursor: 'pointer',\n  fontFamily: 'Lato,Helvetica Neue,Arial,Helvetica,sans-serif',\n  fontSize: '14px',\n  marginRight: '1px',\n  $nest: {\n    '&:hover': {\n      backgroundColor: '#6c7c7c',\n    },\n    '&:active': {\n      backgroundColor: '#6c7c7c',\n    },\n  },\n});\n\nconst redoButtonStyle = style({\n  marginTop: '2px',\n  borderRadius: '2px',\n  display: 'inline-block',\n  cursor: 'pointer',\n  fontFamily: 'Lato,Helvetica Neue,Arial,Helvetica,sans-serif',\n  fontSize: '14px',\n\n  $nest: {\n    '&:hover': {\n      backgroundColor: '#6c7c7c',\n    },\n\n    '&:active': {\n      backgroundColor: '#6c7c7c',\n    },\n  },\n});\n\nexport default UndoRedoButton;\n","/* eslint-disable no-plusplus */\n/* eslint-disable no-nested-ternary */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/* eslint-disable no-unused-vars */\nimport {\n  DiffNode,\n  isChildNode,\n  NodeID,\n  Nodes,\n  Provenance,\n  ProvenanceNode,\n  StateNode,\n} from '@visdesignlab/trrack';\nimport {\n  HierarchyNode,\n  stratify,\n  symbol,\n  symbolCircle,\n  symbolCross,\n  symbolDiamond,\n  symbolSquare,\n  symbolStar,\n  symbolTriangle,\n  symbolWye,\n} from 'd3';\nimport React, { ReactChild, useEffect, useState } from 'react';\nimport { NodeGroup } from 'react-move';\nimport { Popup, Tab } from 'semantic-ui-react';\nimport { style } from 'typestyle';\nimport { BundleMap } from '../Utils/BundleMap';\nimport { EventConfig } from '../Utils/EventConfig';\nimport findBundleParent from '../Utils/findBundleParent';\nimport translate from '../Utils/translate';\nimport { treeLayout } from '../Utils/TreeLayout';\nimport BackboneNode from './BackboneNode';\nimport BookmarkListView from './BookmarkListView';\nimport bundleTransitions from './BundleTransitions';\nimport Link from './Link';\nimport linkTransitions from './LinkTransitions';\nimport nodeTransitions from './NodeTransitions';\nimport { treeColor } from './Styles';\nimport UndoRedoButton from './UndoRedoButton';\n\ninterface ProvVisProps<T, S extends string, A> {\n  root: NodeID;\n  sideOffset?: number;\n  iconOnly?: boolean;\n  current: NodeID;\n  nodeMap: Nodes<S, A>;\n  backboneGutter?: number;\n  gutter?: number;\n  verticalSpace?: number;\n  annotationHeight?: number;\n  clusterVerticalSpace?: number;\n  regularCircleRadius?: number;\n  backboneCircleRadius?: number;\n  regularCircleStroke?: number;\n  backboneCircleStroke?: number;\n  topOffset?: number;\n  textSize?: number;\n  height?: number;\n  width?: number;\n  linkWidth?: number;\n  duration?: number;\n  clusterLabels?: boolean;\n  bundleMap?: BundleMap;\n  eventConfig?: EventConfig<S>;\n  changeCurrent?: (id: NodeID) => void;\n  popupContent?: (nodeId: StateNode<S, A>) => ReactChild;\n  annotationContent?: (nodeId: StateNode<S, A>) => ReactChild;\n  undoRedoButtons?: boolean;\n  bookmarkToggle?: boolean;\n  bookmarkListView?: boolean;\n  editAnnotations?: boolean;\n  prov?: Provenance<T, S, A>;\n  ephemeralUndo?: boolean;\n}\n\nexport type StratifiedMap<T, S, A> = {\n  [key: string]: HierarchyNode<ProvenanceNode<S, A>>;\n};\n\nexport type StratifiedList<T, S, A> = HierarchyNode<ProvenanceNode<S, A>>[];\n\nfunction ProvVis<T, S extends string, A>({\n  nodeMap,\n  root,\n  current,\n  changeCurrent,\n  width = 400,\n  height = 800,\n  iconOnly = false,\n  gutter = 15,\n  backboneGutter = 20,\n  verticalSpace = 50,\n  annotationHeight = 100,\n  clusterVerticalSpace = 50,\n  regularCircleRadius = 4,\n  backboneCircleRadius = 5,\n  regularCircleStroke = 3,\n  backboneCircleStroke = 3,\n  sideOffset = 200,\n  topOffset = 30,\n  textSize = 15,\n  linkWidth = 4,\n  duration = 600,\n  clusterLabels = true,\n  bundleMap = {},\n  eventConfig,\n  popupContent,\n  annotationContent,\n  editAnnotations = false,\n  prov,\n  ephemeralUndo = false,\n}: ProvVisProps<T, S, A>) {\n  const [first, setFirst] = useState(true);\n  const [bookmark, setBookmark] = useState<any>(null);\n  const [annotationOpen, setAnnotationOpen] = useState(-1);\n  const [tabsValue, setValue] = useState(0);\n\n  let list: string[] = [];\n  const eventTypes = new Set<string>();\n  for (const j in nodeMap) {\n    const child = nodeMap[j];\n    if (isChildNode(child)) {\n      if (child.metadata.eventType) {\n        eventTypes.add(child.metadata.eventType);\n      }\n\n      if (\n        child.actionType === 'Ephemeral' &&\n        child.children.length === 1 &&\n        (nodeMap[child.parent].actionType !== 'Ephemeral' ||\n          nodeMap[child.parent].children.length > 1)\n      ) {\n        const group: string[] = [];\n        let curr = child;\n        while (curr.actionType === 'Ephemeral') {\n          group.push(curr.id);\n          if (\n            curr.children.length === 1 &&\n            nodeMap[curr.children[0]].actionType === 'Ephemeral'\n          ) {\n            curr = nodeMap[curr.children[0]] as DiffNode<S, A>;\n          } else {\n            break;\n          }\n        }\n\n        bundleMap[child.id] = {\n          metadata: '',\n          bundleLabel: '',\n          bunchedNodes: group,\n        };\n      }\n    }\n  }\n\n  if (bundleMap) {\n    list = list.concat(Object.keys(bundleMap));\n  }\n\n  function setDefaultConfig<E extends string>(\n    types: Set<string>\n  ): EventConfig<E> {\n    const symbols = [\n      symbol().type(symbolStar).size(50),\n      symbol().type(symbolDiamond),\n      symbol().type(symbolTriangle),\n      symbol().type(symbolCircle),\n      symbol().type(symbolCross),\n      symbol().type(symbolSquare),\n      symbol().type(symbolWye),\n    ];\n\n    // Find nodes in the clusters whose entire cluster is on the backbone.\n    const conf: EventConfig<E> = {};\n    let counter = 0;\n\n    for (const j of types) {\n      conf[j] = {};\n      conf[j].backboneGlyph = (\n        <path\n          strokeWidth={2}\n          className={treeColor(false)}\n          d={symbols[counter]()!}\n        />\n      );\n\n      conf[j].bundleGlyph = (\n        <path\n          strokeWidth={2}\n          className={treeColor(false)}\n          d={symbols[counter]()!}\n        />\n      );\n\n      conf[j].currentGlyph = (\n        <path\n          strokeWidth={2}\n          className={treeColor(true)}\n          d={symbols[counter]()!}\n        />\n      );\n\n      conf[j].regularGlyph = (\n        <path\n          strokeWidth={2}\n          className={treeColor(false)}\n          d={symbols[counter]()!}\n        />\n      );\n\n      counter += 1;\n    }\n\n    return conf;\n  }\n\n  const [expandedClusterList, setExpandedClusterList] = useState<string[]>(\n    Object.keys(bundleMap)\n  );\n\n  if (!eventConfig && eventTypes.size > 0 && eventTypes.size < 8) {\n    eventConfig = setDefaultConfig<S>(eventTypes);\n  }\n\n  useEffect(() => {\n    setFirst(false);\n  }, []);\n\n  const nodeList = Object.values(nodeMap).filter(() => true);\n\n  const copyList = Array.from(nodeList);\n\n  const keys = bundleMap ? Object.keys(bundleMap) : [];\n\n  // Find a list of all nodes included in a bundle.\n  let bundledNodes: string[] = [];\n\n  if (bundleMap) {\n    for (const key of keys) {\n      bundledNodes = bundledNodes.concat(bundleMap[key].bunchedNodes);\n      bundledNodes.push(key);\n    }\n  }\n\n  const strat = stratify<ProvenanceNode<S, A>>()\n    .id((d) => d.id)\n    .parentId((d) => {\n      if (d.id === root) return null;\n\n      if (isChildNode(d)) {\n        // If you are a unexpanded bundle, find your parent by going straight up.\n        if (\n          bundleMap &&\n          Object.keys(bundleMap).includes(d.id) &&\n          !expandedClusterList.includes(d.id)\n        ) {\n          let curr = d;\n\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const localCurr = curr;\n\n            if (\n              !bundledNodes.includes(localCurr.parent) ||\n              Object.keys(bundleMap).includes(localCurr.parent)\n            ) {\n              return localCurr.parent;\n            }\n\n            const temp = copyList.filter((c) => c.id === localCurr.parent)[0];\n\n            if (isChildNode(temp)) {\n              curr = temp;\n            }\n          }\n        }\n\n        const bundleParents = findBundleParent(d.parent, bundleMap);\n        let collapsedParent;\n\n        let allExpanded = true;\n\n        for (const j in bundleParents) {\n          if (!expandedClusterList.includes(bundleParents[j])) {\n            allExpanded = false;\n            collapsedParent = bundleParents[j];\n            break;\n          }\n        }\n\n        if (\n          bundledNodes.includes(d.parent) &&\n          bundleMap &&\n          !Object.keys(bundleMap).includes(d.parent) &&\n          !allExpanded\n        ) {\n          return collapsedParent;\n        }\n\n        return d.parent;\n      }\n      return null;\n    });\n\n  for (let i = 0; i < nodeList.length; i++) {\n    const bundleParents = findBundleParent(nodeList[i].id, bundleMap);\n\n    let allExpanded = true;\n\n    for (const j in bundleParents) {\n      if (!expandedClusterList.includes(bundleParents[j])) {\n        allExpanded = false;\n        break;\n      }\n    }\n\n    if (\n      bundledNodes.includes(nodeList[i].id) &&\n      !allExpanded &&\n      bundleMap &&\n      !Object.keys(bundleMap).includes(nodeList[i].id)\n    ) {\n      nodeList.splice(i, 1);\n      i--;\n    }\n  }\n\n  const stratifiedTree = strat(nodeList);\n\n  // //console.log(JSON.parse(JSON.stringify(stratifiedTree)));\n\n  const stratifiedList: StratifiedList<T, S, A> = stratifiedTree.descendants();\n  const stratifiedMap: StratifiedMap<T, S, A> = {};\n\n  stratifiedList.forEach((c) => {\n    stratifiedMap[c.id!] = c;\n  });\n  treeLayout(stratifiedMap, current, root);\n\n  let maxHeight = 0;\n  let maxWidth = 0;\n\n  for (const j in stratifiedList) {\n    if (stratifiedList[j].depth > maxHeight) {\n      maxHeight = stratifiedList[j].depth;\n    }\n\n    if ((stratifiedList[j] as any).width > maxWidth) {\n      maxWidth = (stratifiedList[j] as any).width;\n    }\n  }\n\n  const links = stratifiedTree.links();\n\n  const xOffset = gutter;\n  const yOffset = verticalSpace;\n\n  function regularGlyph(node: ProvenanceNode<S, A>) {\n    if (eventConfig) {\n      const { eventType } = node.metadata;\n      if (\n        eventType &&\n        eventType in eventConfig &&\n        eventType !== 'Root' &&\n        eventConfig[eventType].regularGlyph\n      ) {\n        return eventConfig[eventType].regularGlyph;\n      }\n    }\n    return (\n      <circle\n        r={regularCircleRadius}\n        strokeWidth={regularCircleStroke}\n        className={treeColor(false)}\n      />\n    );\n  }\n\n  function bundleGlyph(node: ProvenanceNode<S, A>) {\n    if (eventConfig) {\n      const { eventType } = node.metadata;\n      if (eventType && eventType in eventConfig && eventType !== 'Root') {\n        return eventConfig[eventType].bundleGlyph;\n      }\n    }\n\n    return (\n      <circle\n        r={regularCircleRadius}\n        strokeWidth={regularCircleStroke}\n        className={treeColor(false)}\n      />\n    );\n  }\n\n  let shiftLeft = 0;\n\n  if (maxWidth === 0) {\n    shiftLeft = 30;\n  } else if (maxWidth === 1) {\n    shiftLeft = 52;\n  } else if (maxWidth > 1) {\n    shiftLeft = 74;\n  }\n\n  const svgWidth = width;\n\n  const overflowStyle = {\n    overflowX: 'auto',\n    overflowY: 'auto',\n  } as React.CSSProperties;\n\n  const tabsStyle = {\n    backgroundColor: 'lightgrey',\n    width: '270px',\n  } as React.CSSProperties;\n\n  const bookmarkTabView = (\n    <svg\n      style={{ overflow: 'visible' }}\n      height={maxHeight < height ? height : maxHeight}\n      width={svgWidth}\n      id=\"bookmarkView\"\n    >\n      <g id={'globalG'} transform={translate(shiftLeft, topOffset)}>\n        <BookmarkListView\n          graph={prov ? prov.graph : undefined}\n          eventConfig={eventConfig}\n          currentNode={current}\n        />\n      </g>\n    </svg>\n  );\n\n  const graphTabView = (\n    <div>\n      <div id=\"undoRedoDiv\">\n        <UndoRedoButton\n          graph={prov ? prov.graph : undefined}\n          undoCallback={() => {\n            if (prov) {\n              if (ephemeralUndo) {\n                prov.goBackToNonEphemeral();\n              } else {\n                prov.goBackOneStep();\n              }\n            }\n          }}\n          redoCallback={() => {\n            if (prov) {\n              if (ephemeralUndo) {\n                prov.goForwardToNonEphemeral();\n              } else {\n                prov.goForwardOneStep();\n              }\n            }\n          }}\n        />\n      </div>\n\n      <svg\n        style={{ overflow: 'visible' }}\n        id={'topSvg'}\n        height={maxHeight < height ? height : maxHeight}\n        width={svgWidth}\n      >\n        <rect height={height} width={width} fill=\"none\" stroke=\"none\" />\n        <g id={'globalG'} transform={translate(shiftLeft, topOffset)}>\n          <NodeGroup\n            data={links}\n            keyAccessor={(link) => `${link.source.id}${link.target.id}`}\n            {...linkTransitions(\n              xOffset,\n              yOffset,\n              clusterVerticalSpace,\n              backboneGutter - gutter,\n              duration,\n              annotationOpen,\n              annotationHeight\n            )}\n          >\n            {(linkArr) => (\n              <>\n                {linkArr.map((link) => {\n                  const { key, state } = link;\n\n                  return (\n                    <g key={key}>\n                      <Link\n                        {...state}\n                        fill={'#ccc'}\n                        stroke={'#ccc'}\n                        strokeWidth={linkWidth}\n                      />\n                    </g>\n                  );\n                })}\n              </>\n            )}\n          </NodeGroup>\n          <NodeGroup\n            data={stratifiedList}\n            keyAccessor={(d) => d.id}\n            {...nodeTransitions(\n              xOffset,\n              yOffset,\n              clusterVerticalSpace,\n              backboneGutter - gutter,\n              duration,\n              annotationOpen,\n              annotationHeight\n            )}\n          >\n            {(nodes) => (\n              <>\n                {nodes.map((node) => {\n                  const { data: d, key, state } = node;\n                  const popupTrigger = (\n                    <g\n                      key={key}\n                      onClick={() => {\n                        if (changeCurrent) {\n                          changeCurrent(d.id);\n                        }\n                      }}\n                      onMouseOver={() => {\n                        setBookmark(d.id);\n                      }}\n                      onMouseOut={() => {\n                        setBookmark(null);\n                      }}\n                      transform={\n                        d.width === 0\n                          ? translate(state.x, state.y)\n                          : translate(state.x, state.y)\n                      }\n                    >\n                      {d.width === 0 && prov ? (\n                        <g>\n                          <rect\n                            width=\"200\"\n                            height=\"25\"\n                            transform=\"translate(0, -12.5)\"\n                            opacity=\"0\"\n                          ></rect>\n                          ,\n                          <BackboneNode\n                            prov={prov}\n                            textSize={textSize}\n                            iconOnly={iconOnly}\n                            radius={backboneCircleRadius}\n                            strokeWidth={backboneCircleStroke}\n                            duration={duration}\n                            first={first}\n                            current={current === d.id}\n                            node={d.data}\n                            setBookmark={setBookmark}\n                            bookmark={bookmark}\n                            bundleMap={bundleMap}\n                            nodeMap={stratifiedMap}\n                            clusterLabels={clusterLabels}\n                            annotationOpen={annotationOpen}\n                            setAnnotationOpen={setAnnotationOpen}\n                            exemptList={expandedClusterList}\n                            editAnnotations={editAnnotations}\n                            setExemptList={setExpandedClusterList}\n                            eventConfig={eventConfig}\n                            annotationContent={annotationContent}\n                            popupContent={popupContent}\n                            expandedClusterList={expandedClusterList}\n                          />\n                        </g>\n                      ) : popupContent !== undefined ? (\n                        <Popup\n                          content={popupContent(d.data)}\n                          trigger={\n                            <g\n                              onClick={() => {\n                                setAnnotationOpen(-1);\n                              }}\n                            >\n                              {keys.includes(d.id)\n                                ? bundleGlyph(d.data)\n                                : regularGlyph(d.data)}\n                            </g>\n                          }\n                        />\n                      ) : (\n                        <g\n                          onClick={() => {\n                            setAnnotationOpen(-1);\n                          }}\n                        >\n                          {regularGlyph(d.data)}\n                        </g>\n                      )}\n                    </g>\n                  );\n\n                  return popupTrigger;\n                })}\n              </>\n            )}\n          </NodeGroup>\n          <NodeGroup\n            data={keys}\n            keyAccessor={(key) => `${key}`}\n            {...bundleTransitions(\n              xOffset,\n              verticalSpace,\n              clusterVerticalSpace,\n              backboneGutter - gutter,\n              duration,\n              expandedClusterList,\n              stratifiedMap,\n              stratifiedList,\n              annotationOpen,\n              annotationHeight,\n              bundleMap\n            )}\n          >\n            {(bundle) => (\n              <>\n                {bundle.map((b) => {\n                  const { key, state } = b;\n                  if (\n                    bundleMap === undefined ||\n                    (stratifiedMap[b.key] as any).width !== 0 ||\n                    state.validity === false\n                  ) {\n                    return null;\n                  }\n\n                  return (\n                    <g\n                      key={key}\n                      transform={translate(\n                        state.x - gutter + 5,\n                        state.y - clusterVerticalSpace / 2\n                      )}\n                    >\n                      <rect\n                        style={{ opacity: state.opacity }}\n                        width={iconOnly ? 42 : sideOffset - 15}\n                        height={state.height}\n                        rx=\"10\"\n                        ry=\"10\"\n                        fill=\"none\"\n                        strokeWidth=\"2px\"\n                        stroke=\"rgb(248, 191, 132)\"\n                      ></rect>\n                    </g>\n                  );\n                })}\n              </>\n            )}\n          </NodeGroup>\n        </g>\n      </svg>\n    </div>\n  );\n\n  const panes = [\n    {\n      menuItem: { key: 'Graph', icon: 'share alternate', content: 'Graph' },\n      render: () => <Tab.Pane attached={false}>{graphTabView}</Tab.Pane>,\n    },\n    {\n      menuItem: {\n        key: 'Bookmarks/Annotations',\n        icon: 'bookmark',\n        content: 'Bookmarks/Annotations',\n      },\n      render: () => <Tab.Pane attached={false}>{bookmarkTabView}</Tab.Pane>,\n    },\n  ];\n\n  return (\n    <div style={overflowStyle} className={container} id=\"prov-vis\">\n      <Tab menu={{ secondary: true, pointing: true }} panes={panes} />\n    </div>\n  );\n}\n\nexport default ProvVis;\n\nconst container = style({\n  alignItems: 'center',\n  justifyContent: 'center',\n  overflow: 'auto',\n});\n","import { ProvenanceNode } from '@visdesignlab/trrack';\nimport { HierarchyNode } from 'd3';\nimport { StratifiedMap } from '../components/ProvVis';\n\nexport type TreeNode = HierarchyNode<unknown>;\n\nexport interface ExtendedHierarchyNode<T, S, A>\n  extends HierarchyNode<ProvenanceNode<S, A>> {\n  column: number;\n}\n\nexport type ExtendedStratifiedMap<T, S, A> = {\n  [key: string]: ExtendedHierarchyNode<T, S, A>;\n};\n\nexport function treeLayout<T, S, A>(\n  nodes: StratifiedMap<T, S, A>,\n  current: string,\n  root: string\n) {\n  const depthMap: { [key: string]: any } = {};\n\n  const currentPath = getPathTo(nodes, root, current);\n\n  DFS(nodes, root, depthMap, currentPath);\n\n  return currentPath;\n}\n\nfunction DFS<T, S, A>(\n  nodes: StratifiedMap<T, S, A>,\n  node: string,\n  depthMap: any,\n  currentPath: string[]\n) {\n  const explored = new Set();\n\n  const toExplore = [];\n\n  let currDepth = 0;\n\n  toExplore.push(nodes[node]);\n\n  while (toExplore.length > 0) {\n    const temp: any = toExplore.pop();\n\n    if (!explored.has(temp.id)) {\n      temp.width = currDepth;\n      depthMap[temp.id] = temp.width;\n      explored.add(temp.id);\n    } else {\n      temp.width = depthMap[temp.id];\n    }\n\n    if (temp.children) {\n      toExplore.push(\n        ...temp.children.sort((a: any, b: any) => {\n          const aIncludes = currentPath.includes(a.id) ? 1 : 0;\n          const bIncludes = currentPath.includes(b.id) ? 1 : 0;\n          return aIncludes - bIncludes;\n        })\n      );\n    } else {\n      currDepth += 1;\n    }\n  }\n}\n\nexport function getPathTo<T, S, A>(\n  nodes: StratifiedMap<T, S, A>,\n  from: string,\n  to: string\n): string[] {\n  const path: string[] = [];\n\n  search(nodes, from, to, path);\n\n  return [from, ...path.reverse()];\n}\n\nfunction search<T, S, A>(\n  nodes: StratifiedMap<T, S, A>,\n  node: string,\n  final: string,\n  path: string[]\n) {\n  if (!nodes[node]) return false;\n\n  if (node === final) {\n    path.push(node);\n    return true;\n  }\n\n  const children = nodes[node].children || [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const child of children) {\n    if (search(nodes, child.id!, final, path)) {\n      path.push(child.id!);\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { getX } from './LinkTransitions';\n\nexport default function nodeTransitions(\n  xOffset: number,\n  yOffset: number,\n  clusterOffset: number,\n  backboneOffset: number,\n  duration = 500,\n  annotationOpen: number,\n  annotationHeight: number\n) {\n  xOffset = -xOffset;\n  backboneOffset = -backboneOffset;\n  const start = (data: any) => {\n    let clusteredNodesInFront = 0;\n\n    const x = getX(data.width, xOffset, backboneOffset);\n    // eslint-disable-next-line max-len\n    clusteredNodesInFront =\n      clusteredNodesInFront === 0\n        ? clusteredNodesInFront\n        : clusteredNodesInFront - 1;\n\n    let y =\n      yOffset * data.depth - (yOffset - clusterOffset) * clusteredNodesInFront;\n\n    if (\n      annotationOpen !== -1 &&\n      data.depth > annotationOpen &&\n      data.width === 0\n    ) {\n      y += annotationHeight;\n    }\n\n    return { x, y: y - yOffset, opacity: 0 };\n  };\n\n  const enter = (data: any) => {\n    let clusteredNodesInFront = 0;\n\n    const x = getX(data.width, xOffset, backboneOffset);\n\n    // eslint-disable-next-line max-len\n    clusteredNodesInFront =\n      clusteredNodesInFront === 0\n        ? clusteredNodesInFront\n        : clusteredNodesInFront - 1;\n\n    let y =\n      yOffset * data.depth - (yOffset - clusterOffset) * clusteredNodesInFront;\n\n    if (\n      annotationOpen !== -1 &&\n      data.depth > annotationOpen &&\n      data.width === 0\n    ) {\n      y += annotationHeight;\n    }\n\n    return {\n      x: [x],\n      y: [y],\n      opactiy: 1,\n      timing: { duration },\n    };\n  };\n\n  const update = (data: any) => {\n    let clusteredNodesInFront = 0;\n\n    const x = getX(data.width, xOffset, backboneOffset);\n\n    // eslint-disable-next-line max-len\n    clusteredNodesInFront =\n      clusteredNodesInFront === 0\n        ? clusteredNodesInFront\n        : clusteredNodesInFront - 1;\n\n    let y =\n      yOffset * data.depth - (yOffset - clusterOffset) * clusteredNodesInFront;\n\n    if (\n      annotationOpen !== -1 &&\n      data.depth > annotationOpen &&\n      data.width === 0\n    ) {\n      y += annotationHeight;\n    }\n\n    return {\n      x: [x],\n      y: [y],\n      opactiy: 1,\n      timing: { duration },\n    };\n  };\n\n  return {\n    enter,\n    leave: start,\n    update,\n    start,\n  };\n}\n","/* eslint-disable no-plusplus */\nimport { getX } from './LinkTransitions';\nimport { BundleMap } from '../Utils/BundleMap';\n\nexport default function bundleTransitions(\n  xOffset: number,\n  yOffset: number,\n  clusterOffset: number,\n  backboneOffset: number,\n  duration = 500,\n  expandedClusterList: string[],\n  stratifiedMap: any,\n  nodeList: any[],\n  annotationOpen: number,\n  annotationHeight: number,\n  bundleMap?: BundleMap\n) {\n  xOffset = -xOffset;\n  backboneOffset = -backboneOffset;\n  const start = () => ({ x: 0, y: 0, opacity: 0 });\n\n  const enter = (data: any) => {\n    const validity = true;\n\n    const x = getX(stratifiedMap[data].width, xOffset, backboneOffset);\n\n    // let backboneBundleNodes = findBackboneBundleNodes(stratifiedMap, bundleMap)\n\n    let highestDepth = stratifiedMap[data].depth;\n    let lowestDepth = stratifiedMap[data].depth;\n\n    if (bundleMap && expandedClusterList.includes(data)) {\n      for (let i = 0; i < bundleMap[data].bunchedNodes.length; i++) {\n        // if(stratifiedMap[bundleMap[data].bunchedNodes[i]].width != 0)\n        // {\n        //   validity = false;\n        // }\n        if (\n          stratifiedMap[bundleMap[data].bunchedNodes[i]] &&\n          stratifiedMap[bundleMap[data].bunchedNodes[i]].depth < highestDepth\n        ) {\n          highestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;\n        }\n\n        if (\n          stratifiedMap[bundleMap[data].bunchedNodes[i]] &&\n          stratifiedMap[bundleMap[data].bunchedNodes[i]].depth > lowestDepth\n        ) {\n          lowestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;\n        }\n      }\n    }\n\n    let y = yOffset * highestDepth;\n\n    if (annotationOpen !== -1 && highestDepth > annotationOpen) {\n      y += annotationHeight;\n    }\n\n    let height = 0;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const j in bundleMap![data].bunchedNodes) {\n      if (stratifiedMap[bundleMap![data].bunchedNodes[j]]) {\n        height++;\n      }\n    }\n\n    height *= clusterOffset;\n\n    if (!expandedClusterList.includes(data)) {\n      height = 10;\n    }\n\n    if (\n      annotationOpen !== -1 &&\n      annotationOpen >= highestDepth &&\n      annotationOpen <= lowestDepth\n    ) {\n      height += annotationHeight;\n    }\n\n    return {\n      x: [x],\n      y: [y],\n      opacity: [!expandedClusterList.includes(data) ? 0 : 1],\n      timing: { duration },\n      validity,\n      height,\n    };\n  };\n\n  const update = (data: any) => {\n    const validity = true;\n\n    const x = getX(stratifiedMap[data].width, xOffset, backboneOffset);\n\n    // let backboneBundleNodes = findBackboneBundleNodes(stratifiedMap, bundleMap)\n\n    let highestDepth = stratifiedMap[data].depth;\n    let lowestDepth = stratifiedMap[data].depth;\n\n    if (bundleMap && expandedClusterList.includes(data)) {\n      for (let i = 0; i < bundleMap[data].bunchedNodes.length; i++) {\n        // if(stratifiedMap[bundleMap[data].bunchedNodes[i]].width != 0)\n        // {\n        //   validity = false;\n        // }\n        if (\n          stratifiedMap[bundleMap[data].bunchedNodes[i]] &&\n          stratifiedMap[bundleMap[data].bunchedNodes[i]].depth < highestDepth\n        ) {\n          highestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;\n        }\n\n        if (\n          stratifiedMap[bundleMap[data].bunchedNodes[i]] &&\n          stratifiedMap[bundleMap[data].bunchedNodes[i]].depth > lowestDepth\n        ) {\n          lowestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;\n        }\n      }\n    }\n\n    let y = yOffset * highestDepth;\n\n    if (annotationOpen !== -1 && highestDepth > annotationOpen) {\n      y += annotationHeight;\n    }\n\n    let height = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    for (const j in bundleMap![data].bunchedNodes) {\n      if (stratifiedMap[bundleMap![data].bunchedNodes[j]]) {\n        height++;\n      }\n    }\n\n    height *= clusterOffset;\n\n    if (!expandedClusterList.includes(data)) {\n      height = 10;\n    }\n\n    if (\n      annotationOpen !== -1 &&\n      annotationOpen >= highestDepth &&\n      annotationOpen <= lowestDepth\n    ) {\n      height += annotationHeight;\n    }\n\n    return {\n      x: [x],\n      y: [y],\n      opacity: [!expandedClusterList.includes(data) ? 0 : 1],\n      timing: { duration },\n      validity,\n      height: [height],\n    };\n  };\n  return {\n    enter,\n    leave: start,\n    update,\n    start,\n  };\n}\n","/* eslint-disable no-unused-vars */\nimport { NodeID, Provenance, ProvenanceGraph } from '@visdesignlab/trrack';\nimport { configure } from 'mobx';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BundleMap } from '../Utils/BundleMap';\nimport { EventConfig } from '../Utils/EventConfig';\nimport ProvVis from './ProvVis';\nimport UndoRedoButton from './UndoRedoButton';\n\nexport interface ProvVisConfig {\n  eventConfig: EventConfig<any>;\n  editAnnotations: boolean;\n  bundleMap: BundleMap;\n  iconOnly: boolean;\n  iconSize: number;\n  height: number;\n  width: number;\n  sideOffset: number;\n  backboneGutter: number;\n  gutter: number;\n  verticalSpace: number;\n  regularCircleRadius: number;\n  backboneCircleRadius: number;\n  regularCircleStroke: number;\n  backboneCircleStroke: number;\n  topOffset: number;\n  textSize: number;\n  linkWidth: number;\n  duration: number;\n}\nconfigure({ isolateGlobalState: true });\nexport function ProvVisCreator<T, S extends string, A>(\n  node: Element,\n  prov: Provenance<T, S, A>,\n  callback?: (id: NodeID) => void,\n  buttons = true,\n  ephemeralUndo = false,\n  fauxRoot: NodeID = prov.graph.root,\n  config: Partial<ProvVisConfig> = {}\n) {\n  prov.addGlobalObserver(() => {\n    ReactDOM.render(\n      <ProvVis\n        {...config}\n        root={fauxRoot}\n        changeCurrent={callback}\n        current={prov.graph.current}\n        nodeMap={prov.graph.nodes}\n        prov={prov}\n        undoRedoButtons={true}\n        ephemeralUndo={ephemeralUndo}\n      />,\n      node\n    );\n  });\n\n  ReactDOM.render(\n    <ProvVis\n      {...config}\n      root={fauxRoot}\n      changeCurrent={callback}\n      current={prov.graph.current}\n      nodeMap={prov.graph.nodes}\n      prov={prov}\n      undoRedoButtons={true}\n      ephemeralUndo={ephemeralUndo}\n    />,\n    node\n  );\n}\n\nexport function UndoRedoButtonCreator<T, S extends string, A>(\n  node: Element,\n  graph: ProvenanceGraph<S, A>,\n  undoCallback: () => void,\n  redoCallback: () => void\n) {\n  ReactDOM.render(\n    <UndoRedoButton\n      graph={graph}\n      undoCallback={undoCallback}\n      redoCallback={redoCallback}\n    />,\n    node\n  );\n}\n"],"names":["findBundleParent","nodeId","bundleMap","parentList","bundle","bunchedNodes","includes","push","translate","x","y","treeColor","current","style","fill","stroke","BackboneNode","prov","first","iconOnly","node","duration","radius","strokeWidth","textSize","nodeMap","annotationOpen","bookmark","setAnnotationOpen","exemptList","setExemptList","eventConfig","popupContent","editAnnotations","annotationContent","expandedClusterList","cursorStyle","cursor","useState","getLatestAnnotation","id","annotation","_prov$getLatestAnnota2","annotateText","setAnnotateText","handleCheck","lastAnnotation","trim","addAnnotation","handleClose","_prov$getLatestAnnota3","handleInputChange","glyph","React","className","r","dropDownAdded","eventType","metadata","bundleGlyph","currentGlyph","backboneGlyph","Object","keys","fontWeight","label","annotate","actionType","length","artifacts","annotations","depth","substr","labelG","opacity","transform","onClick","e","nodeClicked","fontSize","textAnchor","alignmentBaseline","fontFamily","dominantBaseline","labelClicked","setBookmark","getBookmark","stopPropagation","Animate","start","enter","timing","delay","undefined","Popup","content","trigger","width","height","maxWidth","resize","onChange","value","innerNode","event","exemptCopy","Array","from","splice","findIndex","d","BookmarkNode","BookmarkListView","graph","currentNode","nodeList","bookmarks","j","nodes","bookmarked","NodeGroup","data","keyAccessor","opactiy","leave","update","innerBookmarks","map","state","key","getX","xOffset","backboneOffset","Link","props","UndoRedoButton","redoCallback","isAtLatest","children","margin","marginRight","Button","variant","undoButtonStyle","disabled","root","undoCallback","redoButtonStyle","marginTop","borderRadius","display","$nest","backgroundColor","ProvVis","changeCurrent","gutter","backboneGutter","verticalSpace","annotationHeight","clusterVerticalSpace","regularCircleRadius","backboneCircleRadius","regularCircleStroke","backboneCircleStroke","sideOffset","topOffset","linkWidth","clusterLabels","ephemeralUndo","setFirst","list","eventTypes","Set","child","isChildNode","add","parent","group","curr","bundleLabel","concat","setExpandedClusterList","size","types","symbols","symbol","type","symbolStar","symbolDiamond","symbolTriangle","symbolCircle","symbolCross","symbolSquare","symbolWye","conf","counter","regularGlyph","setDefaultConfig","useEffect","values","filter","copyList","bundledNodes","strat","stratify","parentId","localCurr","temp","c","collapsedParent","bundleParents","allExpanded","i","stratifiedTree","stratifiedList","descendants","stratifiedMap","forEach","depthMap","currentPath","explored","toExplore","currDepth","pop","has","sort","a","b","DFS","to","path","search","final","reverse","getPathTo","treeLayout","maxHeight","links","yOffset","shiftLeft","svgWidth","bookmarkTabView","overflow","graphTabView","goBackToNonEphemeral","goBackOneStep","goForwardToNonEphemeral","goForwardOneStep","link","source","target","clusterOffset","x1","x2","y1","y2","clusteredNodesInFront","linkTransitions","linkArr","nodeTransitions","onMouseOver","onMouseOut","highestDepth","lowestDepth","validity","bundleTransitions","rx","ry","panes","menuItem","icon","render","Tab","Pane","attached","overflowX","overflowY","container","menu","secondary","pointing","alignItems","justifyContent","isolateGlobalState","callback","buttons","fauxRoot","config","addGlobalObserver","ReactDOM","undoRedoButtons"],"mappings":"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"}