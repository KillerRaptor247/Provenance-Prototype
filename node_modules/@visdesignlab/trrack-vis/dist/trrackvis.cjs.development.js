'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var trrack = require('@visdesignlab/trrack');
var d3 = require('d3');
var React = require('react');
var React__default = _interopDefault(React);
var reactMove = require('react-move');
var semanticUiReact = require('semantic-ui-react');
var typestyle = require('typestyle');
var mobx = require('mobx');
var ReactDOM = _interopDefault(require('react-dom'));

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function findBundleParent(nodeId, bundleMap) {
  var parentList = []; // eslint-disable-next-line no-restricted-syntax

  for (var bundle in bundleMap) {
    if (bundleMap[bundle].bunchedNodes.includes(nodeId)) {
      parentList.push(bundle);
    }
  }

  return parentList;
}

function translate(x, y) {
  return "translate(" + x + ", " + y + ")";
}

function treeLayout(nodes, current, root) {
  var depthMap = {};
  var currentPath = getPathTo(nodes, root, current);
  DFS(nodes, root, depthMap, currentPath);
  return currentPath;
}

function DFS(nodes, node, depthMap, currentPath) {
  var explored = new Set();
  var toExplore = [];
  var currDepth = 0;
  toExplore.push(nodes[node]);

  while (toExplore.length > 0) {
    var temp = toExplore.pop();

    if (!explored.has(temp.id)) {
      temp.width = currDepth;
      depthMap[temp.id] = temp.width;
      explored.add(temp.id);
    } else {
      temp.width = depthMap[temp.id];
    }

    if (temp.children) {
      toExplore.push.apply(toExplore, temp.children.sort(function (a, b) {
        var aIncludes = currentPath.includes(a.id) ? 1 : 0;
        var bIncludes = currentPath.includes(b.id) ? 1 : 0;
        return aIncludes - bIncludes;
      }));
    } else {
      currDepth += 1;
    }
  }
}

function getPathTo(nodes, from, to) {
  var path = [];
  search(nodes, from, to, path);
  return [from].concat(path.reverse());
}

function search(nodes, node, _final, path) {
  if (!nodes[node]) return false;

  if (node === _final) {
    path.push(node);
    return true;
  }

  var children = nodes[node].children || []; // eslint-disable-next-line no-restricted-syntax

  for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
    var child = _step.value;

    if (search(nodes, child.id, _final, path)) {
      path.push(child.id);
      return true;
    }
  }

  return false;
}

var treeColor = function treeColor(current) {
  return typestyle.style({
    fill: current ? 'rgb(33, 133, 208)' : 'white',
    stroke: 'rgb(33, 133, 208)'
  });
};

function BackboneNode(_ref) {
  var _prov$getLatestAnnota, _prov$getLatestAnnota2;

  var prov = _ref.prov,
      first = _ref.first,
      iconOnly = _ref.iconOnly,
      current = _ref.current,
      node = _ref.node,
      duration = _ref.duration,
      radius = _ref.radius,
      strokeWidth = _ref.strokeWidth,
      textSize = _ref.textSize,
      nodeMap = _ref.nodeMap,
      annotationOpen = _ref.annotationOpen,
      bookmark = _ref.bookmark,
      setAnnotationOpen = _ref.setAnnotationOpen,
      exemptList = _ref.exemptList,
      setExemptList = _ref.setExemptList,
      bundleMap = _ref.bundleMap,
      eventConfig = _ref.eventConfig,
      popupContent = _ref.popupContent,
      editAnnotations = _ref.editAnnotations,
      annotationContent = _ref.annotationContent,
      expandedClusterList = _ref.expandedClusterList;
  var padding = 15;
  var cursorStyle = {
    cursor: 'pointer'
  };

  var _useState = React.useState(((_prov$getLatestAnnota = prov.getLatestAnnotation(node.id)) == null ? void 0 : _prov$getLatestAnnota.annotation) ? (_prov$getLatestAnnota2 = prov.getLatestAnnotation(node.id)) == null ? void 0 : _prov$getLatestAnnota2.annotation : ''),
      annotateText = _useState[0],
      setAnnotateText = _useState[1];

  var handleCheck = function handleCheck() {
    var lastAnnotation = prov.getLatestAnnotation(node.id);

    if ((lastAnnotation == null ? void 0 : lastAnnotation.annotation) !== annotateText.trim()) {
      prov.addAnnotation(annotateText, node.id);
      setAnnotationOpen(-1);
    }
  };

  var handleClose = function handleClose() {
    var _prov$getLatestAnnota3;

    setAnnotateText((_prov$getLatestAnnota3 = prov.getLatestAnnotation(node.id)) == null ? void 0 : _prov$getLatestAnnota3.annotation);
    setAnnotationOpen(-1);
  };

  var handleInputChange = function handleInputChange() {}; // console.log(JSON.parse(JSON.stringify(node)));


  var glyph = React__default.createElement("circle", {
    style: cursorStyle,
    className: treeColor(current),
    r: radius,
    strokeWidth: strokeWidth
  }); // let backboneBundleNodes = findBackboneBundleNodes(nodeMap, bundleMap)

  var dropDownAdded = false;

  if (eventConfig) {
    var eventType = node.metadata.eventType;

    if (eventType && eventType in eventConfig && eventType !== 'Root') {
      var _eventConfig$eventTyp = eventConfig[eventType],
          bundleGlyph = _eventConfig$eventTyp.bundleGlyph,
          currentGlyph = _eventConfig$eventTyp.currentGlyph,
          backboneGlyph = _eventConfig$eventTyp.backboneGlyph;

      if (bundleMap && Object.keys(bundleMap).includes(node.id)) {
        dropDownAdded = true;
        glyph = React__default.createElement("g", {
          style: cursorStyle,
          fontWeight: 'none'
        }, bundleGlyph);
      }

      if (current) {
        glyph = React__default.createElement("g", {
          style: cursorStyle,
          fontWeight: 'none'
        }, currentGlyph);
      } else if (!dropDownAdded) {
        glyph = React__default.createElement("g", {
          style: cursorStyle,
          fontWeight: 'none'
        }, backboneGlyph);
      }
    }
  }

  var label = '';
  var annotate = ''; // console.log(bundleMap)
  // console.log(nodeMap[node.id]);

  if (bundleMap && Object.keys(bundleMap).includes(node.id) && node.actionType === 'Ephemeral' && expandedClusterList && !expandedClusterList.includes(node.id)) {
    if (node.metadata && node.metadata.eventType) {
      label = "[" + bundleMap[node.id].bunchedNodes.length + "] " + node.metadata.eventType;
    } else {
      label = "[" + bundleMap[node.id].bunchedNodes.length + "]";
    }
  } else {
    label = node.label;
  }

  if (node.artifacts && node.artifacts.annotations.length > 0 && annotationOpen !== nodeMap[node.id].depth) {
    annotate = node.artifacts.annotations[0].annotation;
  }

  if (!nodeMap[node.id]) {
    return null;
  }

  if (annotate.length > 20) annotate = annotate.substr(0, 20) + "..";
  if (label.length > 20) label = label.substr(0, 20) + "..";
  var labelG = React__default.createElement("g", {
    style: {
      opacity: 1
    },
    transform: translate(padding, 0)
  }, !iconOnly ? React__default.createElement("g", null, dropDownAdded ? React__default.createElement("text", {
    style: cursorStyle,
    onClick: function onClick(e) {
      return nodeClicked(node, e);
    },
    fontSize: 17,
    fill: 'rgb(248, 191, 132)',
    textAnchor: "middle",
    alignmentBaseline: "middle",
    x: 1,
    y: 0,
    fontFamily: "Icons"
  }, expandedClusterList && expandedClusterList.includes(node.id) ? "\uF0D8" : "\uF0D7") : React__default.createElement("g", null), editAnnotations ? React__default.createElement("button", null, React__default.createElement("i", {
    className: "fas fa-undo marginRight"
  }), "Undo") : React__default.createElement("g", null), React__default.createElement("text", {
    y: annotate.length === 0 ? 0 : -7,
    x: dropDownAdded ? 10 : 0,
    dominantBaseline: "middle",
    textAnchor: "start",
    fontSize: textSize,
    fontWeight: 'bold',
    onClick: function onClick() {
      return labelClicked(node);
    }
  }, label), ",", React__default.createElement("text", {
    y: 7,
    x: dropDownAdded ? 10 : 0,
    dominantBaseline: "middle",
    textAnchor: "start",
    fontSize: textSize,
    fontWeight: 'regular',
    onClick: function onClick() {
      return labelClicked(node);
    }
  }, annotate), ",", React__default.createElement("text", {
    style: cursorStyle,
    onClick: function onClick(e) {
      prov.setBookmark(node.id, !prov.getBookmark(node.id));
      e.stopPropagation();
    },
    fontSize: 17,
    className: "fas fa",
    opacity: bookmark === node.id || prov.getBookmark(node.id) ? 1 : 0,
    fill: prov.getBookmark(node.id) ? '#2185d0' : '#cccccc',
    textAnchor: "middle",
    alignmentBaseline: "middle",
    x: 175,
    y: 0,
    fontFamily: "Icons"
  }, "\uF02E"), ",", React__default.createElement("text", {
    style: cursorStyle,
    onClick: function onClick() {
      if (annotationOpen === -1 || nodeMap[node.id].depth !== annotationOpen) {
        setAnnotationOpen(nodeMap[node.id].depth);
      } else {
        setAnnotationOpen(-1);
      }
    },
    fontSize: 17,
    opacity: bookmark === node.id || annotationOpen === nodeMap[node.id].depth ? 1 : 0,
    fill: annotationOpen === nodeMap[node.id].depth ? '#2185d0' : '#cccccc',
    textAnchor: "middle",
    alignmentBaseline: "middle",
    x: 210,
    y: 0,
    fontFamily: "Icons"
  }, "\uF044")) : React__default.createElement("g", null, dropDownAdded ? React__default.createElement("text", {
    style: cursorStyle,
    onClick: function onClick(e) {
      return nodeClicked(node, e);
    },
    fontSize: 17,
    fill: 'rgb(248, 191, 132)',
    textAnchor: "middle",
    alignmentBaseline: "middle",
    x: 1,
    y: 0,
    fontFamily: "Icons"
  }, expandedClusterList && expandedClusterList.includes(node.id) ? "\uF0D8" : "\uF0D7") : React__default.createElement("g", null)));
  return React__default.createElement(reactMove.Animate, {
    start: {
      opacity: 0
    },
    enter: {
      opacity: [1],
      timing: {
        duration: 100,
        delay: first ? 0 : duration
      }
    }
  }, function () {
    return React__default.createElement(React__default.Fragment, null, popupContent !== undefined && nodeMap[node.id].depth > 0 ? React__default.createElement(semanticUiReact.Popup, {
      content: popupContent(node),
      trigger: glyph
    }) : glyph, popupContent !== undefined && nodeMap[node.id].depth > 0 ? React__default.createElement(semanticUiReact.Popup, {
      content: popupContent(node),
      trigger: labelG
    }) : labelG, annotationOpen !== -1 && nodeMap[node.id].depth === annotationOpen ? React__default.createElement("g", {
      transform: "translate(15, 25)"
    }, React__default.createElement("foreignObject", {
      width: "175",
      height: "80",
      x: "0",
      y: "0"
    }, React__default.createElement("div", null, React__default.createElement("textarea", {
      style: {
        maxWidth: 130,
        resize: 'none'
      },
      onChange: handleInputChange,
      value: annotateText
    }), React__default.createElement("button", {
      onClick: handleCheck
    }, "Annotate"), React__default.createElement("button", {
      onClick: handleClose
    }, "Close")))) : React__default.createElement("g", null));
  });

  function labelClicked(innerNode) {
    if (annotationOpen === nodeMap[innerNode.id].depth && annotationContent) {
      setAnnotationOpen(-1);
    } else if (annotationContent) {
      setAnnotationOpen(nodeMap[innerNode.id].depth);
    }
  }

  function nodeClicked(innerNode, event) {
    if (bundleMap && Object.keys(bundleMap).includes(innerNode.id)) {
      var exemptCopy = Array.from(exemptList);

      if (exemptCopy.includes(innerNode.id)) {
        exemptCopy.splice(exemptCopy.findIndex(function (d) {
          return d === innerNode.id;
        }), 1);
      } else {
        exemptCopy.push(innerNode.id);
      }

      setExemptList(exemptCopy);
    }

    event.stopPropagation();
  }
}
//   label: string;
// }) => {
//   return <text {...props}>{props.label}</text>;
// };

function BookmarkNode(_ref) {
  var current = _ref.current,
      node = _ref.node,
      eventConfig = _ref.eventConfig;
  var radius = 5;
  var strokeWidth = 2;
  var textSize = 15;
  var cursorStyle = {
    cursor: 'pointer'
  };
  var glyph = React__default.createElement("circle", {
    style: cursorStyle,
    className: treeColor(current),
    r: radius,
    strokeWidth: strokeWidth
  });
  var eventType = node.metadata.eventType;

  if (eventConfig) {
    var _eventConfig$eventTyp = eventConfig[eventType],
        currentGlyph = _eventConfig$eventTyp.currentGlyph,
        backboneGlyph = _eventConfig$eventTyp.backboneGlyph;

    if (current) {
      glyph = React__default.createElement("g", {
        style: cursorStyle,
        fontWeight: 'none'
      }, currentGlyph);
    } else {
      glyph = React__default.createElement("g", {
        style: cursorStyle,
        fontWeight: 'none'
      }, backboneGlyph);
    }
  }

  var label = '';
  var annotate = '';

  if (node.artifacts && node.artifacts.annotations.length > 0 && node.artifacts.annotations[0].annotation.length > 0) {
    annotate = node.artifacts.annotations[0].annotation;
  }

  label = node.label;
  if (annotate.length > 20) annotate = annotate.substr(0, 20) + "..";
  if (label.length > 20) label = label.substr(0, 20) + "..";
  return React__default.createElement(reactMove.Animate, {
    start: {
      opacity: 0
    },
    enter: {
      opacity: [1]
    }
  }, function () {
    return React__default.createElement(React__default.Fragment, null, React__default.createElement("g", {
      style: {
        opacity: 1
      }
    }, glyph, React__default.createElement("text", {
      y: 0,
      x: 20,
      dominantBaseline: "middle",
      textAnchor: "start",
      fontSize: textSize,
      fontWeight: 'bold'
    }, label), React__default.createElement("text", {
      y: 20,
      x:  0,
      dominantBaseline: "middle",
      textAnchor: "start",
      fontSize: textSize,
      fontWeight: 'regular'
    }, annotate)));
  });
}

/* eslint-disable no-plusplus */
function BookmarkTransitions(xOffset, yOffset, nodeList) {

  var start = function start(data) {
    var index = nodeList.findIndex(function (d) {
      return d.id === data.id;
    });
    var x = 0;
    var y = 40 * index;
    return {
      x: x,
      y: y - yOffset,
      opacity: 0
    };
  };

  var enter = function enter(data) {
    var index = nodeList.findIndex(function (d) {
      return d.id === data.id;
    });
    var x = 0;
    var y = 40 * index;
    return {
      x: [x],
      y: [y],
      opactiy: 1
    };
  };

  var update = function update(data) {
    var index = nodeList.findIndex(function (d) {
      return d.id === data.id;
    });
    var x = 0;
    var y = 40 * index;
    return {
      x: [x],
      y: [y],
      opactiy: 1
    };
  };

  return {
    enter: enter,
    leave: start,
    update: update,
    start: start
  };
}

function BookmarkListView(_ref) {
  var graph = _ref.graph,
      eventConfig = _ref.eventConfig,
      currentNode = _ref.currentNode;

  if (graph === undefined) {
    return null;
  }

  var gutter = 15;
  var verticalSpace = 50;
  var bookmarks = [];
  var xOffset = gutter;
  var yOffset = verticalSpace; // eslint-disable-next-line no-restricted-syntax

  for (var j in graph.nodes) {
    if (graph.nodes[j].bookmarked) {
      bookmarks.push(graph.nodes[j]);
    }
  }

  return React__default.createElement(reactMove.NodeGroup, Object.assign({
    data: bookmarks,
    keyAccessor: function keyAccessor(d) {
      return d.label;
    }
  }, BookmarkTransitions(xOffset, yOffset, bookmarks)), function (innerBookmarks) {
    return React__default.createElement(React__default.Fragment, null, innerBookmarks.map(function (bookmark) {
      var d = bookmark.data,
          key = bookmark.key,
          state = bookmark.state;
      return React__default.createElement("g", {
        key: key,
        transform: translate(state.x, state.y)
      }, React__default.createElement(BookmarkNode, {
        current: currentNode === d.id,
        node: d,
        nodeMap: innerBookmarks,
        editAnnotations: false,
        eventConfig: eventConfig
      }));
    }));
  });
}

function linkTransitions(xOffset, yOffset, clusterOffset, backboneOffset, duration, annotationOpen, annotationHeight) {
  if (duration === void 0) {
    duration = 500;
  }

  xOffset = -xOffset;
  backboneOffset = -backboneOffset;

  var start = function start() {
    return {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0,
      opacity: 0
    };
  };

  var enter = function enter(data) {
    var clusteredNodesInFront = 0; // eslint-disable-next-line max-len

    clusteredNodesInFront = clusteredNodesInFront === 0 ? clusteredNodesInFront : clusteredNodesInFront - 1;
    var source = data.source,
        target = data.target;
    var x1 = getX(source.width, xOffset, backboneOffset);
    var x2 = getX(target.width, xOffset, backboneOffset);
    var y1 = yOffset * source.depth - (yOffset - clusterOffset) * clusteredNodesInFront;
    var y2 = yOffset * target.depth - (yOffset - clusterOffset) * clusteredNodesInFront;

    if (annotationOpen !== -1 && source.depth > annotationOpen && source.width === 0) {
      y1 += annotationHeight;
    }

    if (annotationOpen !== -1 && target.depth > annotationOpen && target.width === 0) {
      y2 += annotationHeight;
    }

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      opacity: 1,
      timing: {
        duration: duration
      }
    };
  };

  var update = function update(data) {
    var clusteredNodesInFront = 0; // eslint-disable-next-line max-len

    clusteredNodesInFront = clusteredNodesInFront === 0 ? clusteredNodesInFront : clusteredNodesInFront - 1;
    var source = data.source,
        target = data.target;
    var x1 = getX(source.width, xOffset, backboneOffset);
    var x2 = getX(target.width, xOffset, backboneOffset);
    var y1 = yOffset * source.depth - (yOffset - clusterOffset) * clusteredNodesInFront;
    var y2 = yOffset * target.depth - (yOffset - clusterOffset) * clusteredNodesInFront;

    if (annotationOpen !== -1 && source.depth > annotationOpen && source.width === 0) {
      y1 += annotationHeight;
    }

    if (annotationOpen !== -1 && target.depth > annotationOpen && target.width === 0) {
      y2 += annotationHeight;
    }

    return {
      x1: [x1],
      y1: [y1],
      x2: [x2],
      y2: [y2],
      opacity: 1,
      timing: {
        duration: duration
      }
    };
  };

  return {
    enter: enter,
    leave: start,
    update: update,
    start: start
  };
}
function getX(width, xOffset, backboneOffset) {
  return width > 1 ? (xOffset + backboneOffset) * width - backboneOffset : (xOffset + backboneOffset) * width;
}

/* eslint-disable no-plusplus */
function bundleTransitions(xOffset, yOffset, clusterOffset, backboneOffset, duration, expandedClusterList, stratifiedMap, nodeList, annotationOpen, annotationHeight, bundleMap) {
  if (duration === void 0) {
    duration = 500;
  }

  xOffset = -xOffset;
  backboneOffset = -backboneOffset;

  var start = function start() {
    return {
      x: 0,
      y: 0,
      opacity: 0
    };
  };

  var enter = function enter(data) {
    var validity = true;
    var x = getX(stratifiedMap[data].width, xOffset, backboneOffset); // let backboneBundleNodes = findBackboneBundleNodes(stratifiedMap, bundleMap)

    var highestDepth = stratifiedMap[data].depth;
    var lowestDepth = stratifiedMap[data].depth;

    if (bundleMap && expandedClusterList.includes(data)) {
      for (var i = 0; i < bundleMap[data].bunchedNodes.length; i++) {
        // if(stratifiedMap[bundleMap[data].bunchedNodes[i]].width != 0)
        // {
        //   validity = false;
        // }
        if (stratifiedMap[bundleMap[data].bunchedNodes[i]] && stratifiedMap[bundleMap[data].bunchedNodes[i]].depth < highestDepth) {
          highestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;
        }

        if (stratifiedMap[bundleMap[data].bunchedNodes[i]] && stratifiedMap[bundleMap[data].bunchedNodes[i]].depth > lowestDepth) {
          lowestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;
        }
      }
    }

    var y = yOffset * highestDepth;

    if (annotationOpen !== -1 && highestDepth > annotationOpen) {
      y += annotationHeight;
    }

    var height = 0; // eslint-disable-next-line no-restricted-syntax

    for (var j in bundleMap[data].bunchedNodes) {
      if (stratifiedMap[bundleMap[data].bunchedNodes[j]]) {
        height++;
      }
    }

    height *= clusterOffset;

    if (!expandedClusterList.includes(data)) {
      height = 10;
    }

    if (annotationOpen !== -1 && annotationOpen >= highestDepth && annotationOpen <= lowestDepth) {
      height += annotationHeight;
    }

    return {
      x: [x],
      y: [y],
      opacity: [!expandedClusterList.includes(data) ? 0 : 1],
      timing: {
        duration: duration
      },
      validity: validity,
      height: height
    };
  };

  var update = function update(data) {
    var validity = true;
    var x = getX(stratifiedMap[data].width, xOffset, backboneOffset); // let backboneBundleNodes = findBackboneBundleNodes(stratifiedMap, bundleMap)

    var highestDepth = stratifiedMap[data].depth;
    var lowestDepth = stratifiedMap[data].depth;

    if (bundleMap && expandedClusterList.includes(data)) {
      for (var i = 0; i < bundleMap[data].bunchedNodes.length; i++) {
        // if(stratifiedMap[bundleMap[data].bunchedNodes[i]].width != 0)
        // {
        //   validity = false;
        // }
        if (stratifiedMap[bundleMap[data].bunchedNodes[i]] && stratifiedMap[bundleMap[data].bunchedNodes[i]].depth < highestDepth) {
          highestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;
        }

        if (stratifiedMap[bundleMap[data].bunchedNodes[i]] && stratifiedMap[bundleMap[data].bunchedNodes[i]].depth > lowestDepth) {
          lowestDepth = stratifiedMap[bundleMap[data].bunchedNodes[i]].depth;
        }
      }
    }

    var y = yOffset * highestDepth;

    if (annotationOpen !== -1 && highestDepth > annotationOpen) {
      y += annotationHeight;
    }

    var height = 0; // eslint-disable-next-line no-restricted-syntax

    for (var j in bundleMap[data].bunchedNodes) {
      if (stratifiedMap[bundleMap[data].bunchedNodes[j]]) {
        height++;
      }
    }

    height *= clusterOffset;

    if (!expandedClusterList.includes(data)) {
      height = 10;
    }

    if (annotationOpen !== -1 && annotationOpen >= highestDepth && annotationOpen <= lowestDepth) {
      height += annotationHeight;
    }

    return {
      x: [x],
      y: [y],
      opacity: [!expandedClusterList.includes(data) ? 0 : 1],
      timing: {
        duration: duration
      },
      validity: validity,
      height: [height]
    };
  };

  return {
    enter: enter,
    leave: start,
    update: update,
    start: start
  };
}

var Link = function Link(props) {
  return React__default.createElement("line", Object.assign({}, props));
};

function nodeTransitions(xOffset, yOffset, clusterOffset, backboneOffset, duration, annotationOpen, annotationHeight) {
  if (duration === void 0) {
    duration = 500;
  }

  xOffset = -xOffset;
  backboneOffset = -backboneOffset;

  var start = function start(data) {
    var clusteredNodesInFront = 0;
    var x = getX(data.width, xOffset, backboneOffset); // eslint-disable-next-line max-len

    clusteredNodesInFront = clusteredNodesInFront === 0 ? clusteredNodesInFront : clusteredNodesInFront - 1;
    var y = yOffset * data.depth - (yOffset - clusterOffset) * clusteredNodesInFront;

    if (annotationOpen !== -1 && data.depth > annotationOpen && data.width === 0) {
      y += annotationHeight;
    }

    return {
      x: x,
      y: y - yOffset,
      opacity: 0
    };
  };

  var enter = function enter(data) {
    var clusteredNodesInFront = 0;
    var x = getX(data.width, xOffset, backboneOffset); // eslint-disable-next-line max-len

    clusteredNodesInFront = clusteredNodesInFront === 0 ? clusteredNodesInFront : clusteredNodesInFront - 1;
    var y = yOffset * data.depth - (yOffset - clusterOffset) * clusteredNodesInFront;

    if (annotationOpen !== -1 && data.depth > annotationOpen && data.width === 0) {
      y += annotationHeight;
    }

    return {
      x: [x],
      y: [y],
      opactiy: 1,
      timing: {
        duration: duration
      }
    };
  };

  var update = function update(data) {
    var clusteredNodesInFront = 0;
    var x = getX(data.width, xOffset, backboneOffset); // eslint-disable-next-line max-len

    clusteredNodesInFront = clusteredNodesInFront === 0 ? clusteredNodesInFront : clusteredNodesInFront - 1;
    var y = yOffset * data.depth - (yOffset - clusterOffset) * clusteredNodesInFront;

    if (annotationOpen !== -1 && data.depth > annotationOpen && data.width === 0) {
      y += annotationHeight;
    }

    return {
      x: [x],
      y: [y],
      opactiy: 1,
      timing: {
        duration: duration
      }
    };
  };

  return {
    enter: enter,
    leave: start,
    update: update,
    start: start
  };
}

function UndoRedoButton(_ref) {
  var graph = _ref.graph,
      undoCallback = _ref.undoCallback,
      redoCallback = _ref.redoCallback;

  if (graph === undefined) {
    return null;
  }

  var isAtRoot = graph.root === graph.current;
  var isAtLatest = graph.nodes[graph.current].children.length === 0;
  var margin = {
    marginRight: '3px'
  };
  return React__default.createElement("div", null, React__default.createElement(semanticUiReact.Button, {
    variant: "outlined",
    className: undoButtonStyle,
    disabled: isAtRoot,
    onClick: undoCallback
  }, React__default.createElement("i", {
    style: margin,
    className: "fas fa-undo marginRight"
  }), "Undo"), React__default.createElement(semanticUiReact.Button, {
    variant: "outlined",
    className: redoButtonStyle,
    disabled: isAtLatest,
    onClick: redoCallback
  }, React__default.createElement("i", {
    style: margin,
    className: "fas fa-redo marginRight"
  }), "Redo"));
}

var undoButtonStyle = /*#__PURE__*/typestyle.style({
  marginTop: '2px',
  borderRadius: '2px',
  display: 'inline-block',
  cursor: 'pointer',
  fontFamily: 'Lato,Helvetica Neue,Arial,Helvetica,sans-serif',
  fontSize: '14px',
  marginRight: '1px',
  $nest: {
    '&:hover': {
      backgroundColor: '#6c7c7c'
    },
    '&:active': {
      backgroundColor: '#6c7c7c'
    }
  }
});
var redoButtonStyle = /*#__PURE__*/typestyle.style({
  marginTop: '2px',
  borderRadius: '2px',
  display: 'inline-block',
  cursor: 'pointer',
  fontFamily: 'Lato,Helvetica Neue,Arial,Helvetica,sans-serif',
  fontSize: '14px',
  $nest: {
    '&:hover': {
      backgroundColor: '#6c7c7c'
    },
    '&:active': {
      backgroundColor: '#6c7c7c'
    }
  }
});

function ProvVis(_ref) {
  var nodeMap = _ref.nodeMap,
      root = _ref.root,
      current = _ref.current,
      changeCurrent = _ref.changeCurrent,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? 400 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 800 : _ref$height,
      _ref$iconOnly = _ref.iconOnly,
      iconOnly = _ref$iconOnly === void 0 ? false : _ref$iconOnly,
      _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === void 0 ? 15 : _ref$gutter,
      _ref$backboneGutter = _ref.backboneGutter,
      backboneGutter = _ref$backboneGutter === void 0 ? 20 : _ref$backboneGutter,
      _ref$verticalSpace = _ref.verticalSpace,
      verticalSpace = _ref$verticalSpace === void 0 ? 50 : _ref$verticalSpace,
      _ref$annotationHeight = _ref.annotationHeight,
      annotationHeight = _ref$annotationHeight === void 0 ? 100 : _ref$annotationHeight,
      _ref$clusterVerticalS = _ref.clusterVerticalSpace,
      clusterVerticalSpace = _ref$clusterVerticalS === void 0 ? 50 : _ref$clusterVerticalS,
      _ref$regularCircleRad = _ref.regularCircleRadius,
      regularCircleRadius = _ref$regularCircleRad === void 0 ? 4 : _ref$regularCircleRad,
      _ref$backboneCircleRa = _ref.backboneCircleRadius,
      backboneCircleRadius = _ref$backboneCircleRa === void 0 ? 5 : _ref$backboneCircleRa,
      _ref$regularCircleStr = _ref.regularCircleStroke,
      regularCircleStroke = _ref$regularCircleStr === void 0 ? 3 : _ref$regularCircleStr,
      _ref$backboneCircleSt = _ref.backboneCircleStroke,
      backboneCircleStroke = _ref$backboneCircleSt === void 0 ? 3 : _ref$backboneCircleSt,
      _ref$sideOffset = _ref.sideOffset,
      sideOffset = _ref$sideOffset === void 0 ? 200 : _ref$sideOffset,
      _ref$topOffset = _ref.topOffset,
      topOffset = _ref$topOffset === void 0 ? 30 : _ref$topOffset,
      _ref$textSize = _ref.textSize,
      textSize = _ref$textSize === void 0 ? 15 : _ref$textSize,
      _ref$linkWidth = _ref.linkWidth,
      linkWidth = _ref$linkWidth === void 0 ? 4 : _ref$linkWidth,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 600 : _ref$duration,
      _ref$clusterLabels = _ref.clusterLabels,
      clusterLabels = _ref$clusterLabels === void 0 ? true : _ref$clusterLabels,
      _ref$bundleMap = _ref.bundleMap,
      bundleMap = _ref$bundleMap === void 0 ? {} : _ref$bundleMap,
      eventConfig = _ref.eventConfig,
      popupContent = _ref.popupContent,
      annotationContent = _ref.annotationContent,
      _ref$editAnnotations = _ref.editAnnotations,
      editAnnotations = _ref$editAnnotations === void 0 ? false : _ref$editAnnotations,
      prov = _ref.prov,
      _ref$ephemeralUndo = _ref.ephemeralUndo,
      ephemeralUndo = _ref$ephemeralUndo === void 0 ? false : _ref$ephemeralUndo;

  var _useState = React.useState(true),
      first = _useState[0],
      setFirst = _useState[1];

  var _useState2 = React.useState(null),
      bookmark = _useState2[0],
      setBookmark = _useState2[1];

  var _useState3 = React.useState(-1),
      annotationOpen = _useState3[0],
      setAnnotationOpen = _useState3[1];

  var _useState4 = React.useState(0);

  var list = [];
  var eventTypes = new Set();

  for (var j in nodeMap) {
    var child = nodeMap[j];

    if (trrack.isChildNode(child)) {
      if (child.metadata.eventType) {
        eventTypes.add(child.metadata.eventType);
      }

      if (child.actionType === 'Ephemeral' && child.children.length === 1 && (nodeMap[child.parent].actionType !== 'Ephemeral' || nodeMap[child.parent].children.length > 1)) {
        var group = [];
        var curr = child;

        while (curr.actionType === 'Ephemeral') {
          group.push(curr.id);

          if (curr.children.length === 1 && nodeMap[curr.children[0]].actionType === 'Ephemeral') {
            curr = nodeMap[curr.children[0]];
          } else {
            break;
          }
        }

        bundleMap[child.id] = {
          metadata: '',
          bundleLabel: '',
          bunchedNodes: group
        };
      }
    }
  }

  if (bundleMap) {
    list = list.concat(Object.keys(bundleMap));
  }

  function setDefaultConfig(types) {
    var symbols = [d3.symbol().type(d3.symbolStar).size(50), d3.symbol().type(d3.symbolDiamond), d3.symbol().type(d3.symbolTriangle), d3.symbol().type(d3.symbolCircle), d3.symbol().type(d3.symbolCross), d3.symbol().type(d3.symbolSquare), d3.symbol().type(d3.symbolWye)]; // Find nodes in the clusters whose entire cluster is on the backbone.

    var conf = {};
    var counter = 0;

    for (var _iterator = _createForOfIteratorHelperLoose(types), _step; !(_step = _iterator()).done;) {
      var _j = _step.value;
      conf[_j] = {};
      conf[_j].backboneGlyph = React__default.createElement("path", {
        strokeWidth: 2,
        className: treeColor(false),
        d: symbols[counter]()
      });
      conf[_j].bundleGlyph = React__default.createElement("path", {
        strokeWidth: 2,
        className: treeColor(false),
        d: symbols[counter]()
      });
      conf[_j].currentGlyph = React__default.createElement("path", {
        strokeWidth: 2,
        className: treeColor(true),
        d: symbols[counter]()
      });
      conf[_j].regularGlyph = React__default.createElement("path", {
        strokeWidth: 2,
        className: treeColor(false),
        d: symbols[counter]()
      });
      counter += 1;
    }

    return conf;
  }

  var _useState5 = React.useState(Object.keys(bundleMap)),
      expandedClusterList = _useState5[0],
      setExpandedClusterList = _useState5[1];

  if (!eventConfig && eventTypes.size > 0 && eventTypes.size < 8) {
    eventConfig = setDefaultConfig(eventTypes);
  }

  React.useEffect(function () {
    setFirst(false);
  }, []);
  var nodeList = Object.values(nodeMap).filter(function () {
    return true;
  });
  var copyList = Array.from(nodeList);
  var keys = bundleMap ? Object.keys(bundleMap) : []; // Find a list of all nodes included in a bundle.

  var bundledNodes = [];

  if (bundleMap) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(keys), _step2; !(_step2 = _iterator2()).done;) {
      var key = _step2.value;
      bundledNodes = bundledNodes.concat(bundleMap[key].bunchedNodes);
      bundledNodes.push(key);
    }
  }

  var strat = d3.stratify().id(function (d) {
    return d.id;
  }).parentId(function (d) {
    if (d.id === root) return null;

    if (trrack.isChildNode(d)) {
      // If you are a unexpanded bundle, find your parent by going straight up.
      if (bundleMap && Object.keys(bundleMap).includes(d.id) && !expandedClusterList.includes(d.id)) {
        var _curr = d; // eslint-disable-next-line no-constant-condition

        var _loop = function _loop() {
          var localCurr = _curr;

          if (!bundledNodes.includes(localCurr.parent) || Object.keys(bundleMap).includes(localCurr.parent)) {
            return {
              v: localCurr.parent
            };
          }

          var temp = copyList.filter(function (c) {
            return c.id === localCurr.parent;
          })[0];

          if (trrack.isChildNode(temp)) {
            _curr = temp;
          }
        };

        while (true) {
          var _ret = _loop();

          if (typeof _ret === "object") return _ret.v;
        }
      }

      var bundleParents = findBundleParent(d.parent, bundleMap);
      var collapsedParent;
      var allExpanded = true;

      for (var _j2 in bundleParents) {
        if (!expandedClusterList.includes(bundleParents[_j2])) {
          allExpanded = false;
          collapsedParent = bundleParents[_j2];
          break;
        }
      }

      if (bundledNodes.includes(d.parent) && bundleMap && !Object.keys(bundleMap).includes(d.parent) && !allExpanded) {
        return collapsedParent;
      }

      return d.parent;
    }

    return null;
  });

  for (var i = 0; i < nodeList.length; i++) {
    var bundleParents = findBundleParent(nodeList[i].id, bundleMap);
    var allExpanded = true;

    for (var _j3 in bundleParents) {
      if (!expandedClusterList.includes(bundleParents[_j3])) {
        allExpanded = false;
        break;
      }
    }

    if (bundledNodes.includes(nodeList[i].id) && !allExpanded && bundleMap && !Object.keys(bundleMap).includes(nodeList[i].id)) {
      nodeList.splice(i, 1);
      i--;
    }
  }

  var stratifiedTree = strat(nodeList); // //console.log(JSON.parse(JSON.stringify(stratifiedTree)));

  var stratifiedList = stratifiedTree.descendants();
  var stratifiedMap = {};
  stratifiedList.forEach(function (c) {
    stratifiedMap[c.id] = c;
  });
  treeLayout(stratifiedMap, current, root);
  var maxHeight = 0;
  var maxWidth = 0;

  for (var _j4 in stratifiedList) {
    if (stratifiedList[_j4].depth > maxHeight) {
      maxHeight = stratifiedList[_j4].depth;
    }

    if (stratifiedList[_j4].width > maxWidth) {
      maxWidth = stratifiedList[_j4].width;
    }
  }

  var links = stratifiedTree.links();
  var xOffset = gutter;
  var yOffset = verticalSpace;

  function regularGlyph(node) {
    if (eventConfig) {
      var eventType = node.metadata.eventType;

      if (eventType && eventType in eventConfig && eventType !== 'Root' && eventConfig[eventType].regularGlyph) {
        return eventConfig[eventType].regularGlyph;
      }
    }

    return React__default.createElement("circle", {
      r: regularCircleRadius,
      strokeWidth: regularCircleStroke,
      className: treeColor(false)
    });
  }

  function bundleGlyph(node) {
    if (eventConfig) {
      var eventType = node.metadata.eventType;

      if (eventType && eventType in eventConfig && eventType !== 'Root') {
        return eventConfig[eventType].bundleGlyph;
      }
    }

    return React__default.createElement("circle", {
      r: regularCircleRadius,
      strokeWidth: regularCircleStroke,
      className: treeColor(false)
    });
  }

  var shiftLeft = 0;

  if (maxWidth === 0) {
    shiftLeft = 30;
  } else if (maxWidth === 1) {
    shiftLeft = 52;
  } else if (maxWidth > 1) {
    shiftLeft = 74;
  }

  var svgWidth = width;
  var overflowStyle = {
    overflowX: 'auto',
    overflowY: 'auto'
  };
  var bookmarkTabView = React__default.createElement("svg", {
    style: {
      overflow: 'visible'
    },
    height: maxHeight < height ? height : maxHeight,
    width: svgWidth,
    id: "bookmarkView"
  }, React__default.createElement("g", {
    id: 'globalG',
    transform: translate(shiftLeft, topOffset)
  }, React__default.createElement(BookmarkListView, {
    graph: prov ? prov.graph : undefined,
    eventConfig: eventConfig,
    currentNode: current
  })));
  var graphTabView = React__default.createElement("div", null, React__default.createElement("div", {
    id: "undoRedoDiv"
  }, React__default.createElement(UndoRedoButton, {
    graph: prov ? prov.graph : undefined,
    undoCallback: function undoCallback() {
      if (prov) {
        if (ephemeralUndo) {
          prov.goBackToNonEphemeral();
        } else {
          prov.goBackOneStep();
        }
      }
    },
    redoCallback: function redoCallback() {
      if (prov) {
        if (ephemeralUndo) {
          prov.goForwardToNonEphemeral();
        } else {
          prov.goForwardOneStep();
        }
      }
    }
  })), React__default.createElement("svg", {
    style: {
      overflow: 'visible'
    },
    id: 'topSvg',
    height: maxHeight < height ? height : maxHeight,
    width: svgWidth
  }, React__default.createElement("rect", {
    height: height,
    width: width,
    fill: "none",
    stroke: "none"
  }), React__default.createElement("g", {
    id: 'globalG',
    transform: translate(shiftLeft, topOffset)
  }, React__default.createElement(reactMove.NodeGroup, Object.assign({
    data: links,
    keyAccessor: function keyAccessor(link) {
      return "" + link.source.id + link.target.id;
    }
  }, linkTransitions(xOffset, yOffset, clusterVerticalSpace, backboneGutter - gutter, duration, annotationOpen, annotationHeight)), function (linkArr) {
    return React__default.createElement(React__default.Fragment, null, linkArr.map(function (link) {
      var key = link.key,
          state = link.state;
      return React__default.createElement("g", {
        key: key
      }, React__default.createElement(Link, Object.assign({}, state, {
        fill: '#ccc',
        stroke: '#ccc',
        strokeWidth: linkWidth
      })));
    }));
  }), React__default.createElement(reactMove.NodeGroup, Object.assign({
    data: stratifiedList,
    keyAccessor: function keyAccessor(d) {
      return d.id;
    }
  }, nodeTransitions(xOffset, yOffset, clusterVerticalSpace, backboneGutter - gutter, duration, annotationOpen, annotationHeight)), function (nodes) {
    return React__default.createElement(React__default.Fragment, null, nodes.map(function (node) {
      var d = node.data,
          key = node.key,
          state = node.state;
      var popupTrigger = React__default.createElement("g", {
        key: key,
        onClick: function onClick() {
          if (changeCurrent) {
            changeCurrent(d.id);
          }
        },
        onMouseOver: function onMouseOver() {
          setBookmark(d.id);
        },
        onMouseOut: function onMouseOut() {
          setBookmark(null);
        },
        transform: d.width === 0 ? translate(state.x, state.y) : translate(state.x, state.y)
      }, d.width === 0 && prov ? React__default.createElement("g", null, React__default.createElement("rect", {
        width: "200",
        height: "25",
        transform: "translate(0, -12.5)",
        opacity: "0"
      }), ",", React__default.createElement(BackboneNode, {
        prov: prov,
        textSize: textSize,
        iconOnly: iconOnly,
        radius: backboneCircleRadius,
        strokeWidth: backboneCircleStroke,
        duration: duration,
        first: first,
        current: current === d.id,
        node: d.data,
        setBookmark: setBookmark,
        bookmark: bookmark,
        bundleMap: bundleMap,
        nodeMap: stratifiedMap,
        clusterLabels: clusterLabels,
        annotationOpen: annotationOpen,
        setAnnotationOpen: setAnnotationOpen,
        exemptList: expandedClusterList,
        editAnnotations: editAnnotations,
        setExemptList: setExpandedClusterList,
        eventConfig: eventConfig,
        annotationContent: annotationContent,
        popupContent: popupContent,
        expandedClusterList: expandedClusterList
      })) : popupContent !== undefined ? React__default.createElement(semanticUiReact.Popup, {
        content: popupContent(d.data),
        trigger: React__default.createElement("g", {
          onClick: function onClick() {
            setAnnotationOpen(-1);
          }
        }, keys.includes(d.id) ? bundleGlyph(d.data) : regularGlyph(d.data))
      }) : React__default.createElement("g", {
        onClick: function onClick() {
          setAnnotationOpen(-1);
        }
      }, regularGlyph(d.data)));
      return popupTrigger;
    }));
  }), React__default.createElement(reactMove.NodeGroup, Object.assign({
    data: keys,
    keyAccessor: function keyAccessor(key) {
      return "" + key;
    }
  }, bundleTransitions(xOffset, verticalSpace, clusterVerticalSpace, backboneGutter - gutter, duration, expandedClusterList, stratifiedMap, stratifiedList, annotationOpen, annotationHeight, bundleMap)), function (bundle) {
    return React__default.createElement(React__default.Fragment, null, bundle.map(function (b) {
      var key = b.key,
          state = b.state;

      if (bundleMap === undefined || stratifiedMap[b.key].width !== 0 || state.validity === false) {
        return null;
      }

      return React__default.createElement("g", {
        key: key,
        transform: translate(state.x - gutter + 5, state.y - clusterVerticalSpace / 2)
      }, React__default.createElement("rect", {
        style: {
          opacity: state.opacity
        },
        width: iconOnly ? 42 : sideOffset - 15,
        height: state.height,
        rx: "10",
        ry: "10",
        fill: "none",
        strokeWidth: "2px",
        stroke: "rgb(248, 191, 132)"
      }));
    }));
  }))));
  var panes = [{
    menuItem: {
      key: 'Graph',
      icon: 'share alternate',
      content: 'Graph'
    },
    render: function render() {
      return React__default.createElement(semanticUiReact.Tab.Pane, {
        attached: false
      }, graphTabView);
    }
  }, {
    menuItem: {
      key: 'Bookmarks/Annotations',
      icon: 'bookmark',
      content: 'Bookmarks/Annotations'
    },
    render: function render() {
      return React__default.createElement(semanticUiReact.Tab.Pane, {
        attached: false
      }, bookmarkTabView);
    }
  }];
  return React__default.createElement("div", {
    style: overflowStyle,
    className: container,
    id: "prov-vis"
  }, React__default.createElement(semanticUiReact.Tab, {
    menu: {
      secondary: true,
      pointing: true
    },
    panes: panes
  }));
}
var container = /*#__PURE__*/typestyle.style({
  alignItems: 'center',
  justifyContent: 'center',
  overflow: 'auto'
});

mobx.configure({
  isolateGlobalState: true
});
function ProvVisCreator(node, prov, callback, buttons, ephemeralUndo, fauxRoot, config) {

  if (ephemeralUndo === void 0) {
    ephemeralUndo = false;
  }

  if (fauxRoot === void 0) {
    fauxRoot = prov.graph.root;
  }

  if (config === void 0) {
    config = {};
  }

  prov.addGlobalObserver(function () {
    ReactDOM.render(React__default.createElement(ProvVis, Object.assign({}, config, {
      root: fauxRoot,
      changeCurrent: callback,
      current: prov.graph.current,
      nodeMap: prov.graph.nodes,
      prov: prov,
      undoRedoButtons: true,
      ephemeralUndo: ephemeralUndo
    })), node);
  });
  ReactDOM.render(React__default.createElement(ProvVis, Object.assign({}, config, {
    root: fauxRoot,
    changeCurrent: callback,
    current: prov.graph.current,
    nodeMap: prov.graph.nodes,
    prov: prov,
    undoRedoButtons: true,
    ephemeralUndo: ephemeralUndo
  })), node);
}
function UndoRedoButtonCreator(node, graph, undoCallback, redoCallback) {
  ReactDOM.render(React__default.createElement(UndoRedoButton, {
    graph: graph,
    undoCallback: undoCallback,
    redoCallback: redoCallback
  }), node);
}

exports.ProvVis = ProvVis;
exports.ProvVisCreator = ProvVisCreator;
exports.UndoRedoButtonCreator = UndoRedoButtonCreator;
//# sourceMappingURL=trrackvis.cjs.development.js.map
