import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from 'lz-string';
import { toJS, action, computed, reaction, configure, makeAutoObservable } from 'mobx';
import { applyChange, diff } from 'deep-diff';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* eslint-disable no-shadow */
// TODO:: Fix typing, target shouldnt be of type T.
// eslint-disable-next-line no-unused-vars
function deepCopy(target) {
  return JSON.parse(JSON.stringify(target));
}

/* eslint-disable no-shadow */
/**
 * Function for checking if a node is a state node.
 * @template T Represents the given state of an application as defined in initProvenance.
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 * @template A Represents the given "extra" type for storing metadata.
 * Extra is a way to store customized metadata.
 * @param _opts: Given node to check if it is a state node.
 */

function isStateNode(node) {
  return 'parent' in node && 'state' in node;
}
/**
 * Function for checking if a node is a diff node.
 * @template T Represents the given state of an application as defined in initProvenance.
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 * @template A Represents the given "extra" type for storing metadata.
 * Extra is a way to store customized metadata.
 * @param _opts: Given node to check if it is a diff node.
 */

function isDiffNode(node) {
  return 'diffs' in node;
}
/**
 * Function for checking if a node is a child node.
 * @template T Represents the given state of an application as defined in initProvenance.
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 * @template A Represents the given "extra" type for storing metadata.
 *  Extra is a way to store customized metadata.
 * @param _opts: Given node to check if it is a child node.
 */

function isChildNode(node) {
  return 'parent' in node;
}
/**
 * Function for checking if a node is the root node.
 * @template T Represents the given state of an application as defined in initProvenance.
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 * @template A Represents the given "extra" type for storing metadata.
 * Extra is a way to store customized metadata.
 * @param _opts: Given node to check if it is root.
 */

function isRootNode(node) {
  return node.label === 'Root';
}
/**
`* Retrieve the state of a node. `
 * @template T Represents the given state of an application as defined in initProvenance.
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 * @template A Represents the given "extra" type for storing metadata.
 * Extra is a way to store customized metadata.
 * @param graph: Provenance Graph which we are searching for node in
 * @param _opts: Node which we want the state of
 */

function getState(graph, node) {
  if (isRootNode(node) || isStateNode(node)) {
    return toJS(node.state);
  } // eslint-disable-next-line no-underscore-dangle


  var _state = toJS(graph.nodes[node.lastStateNode].state);

  var state = deepCopy(_state); // what is this for?

  node.diffs.forEach(function (diff) {
    applyChange(state, null, diff);
  });
  return state;
}

function defaultDeserializer(o) {
  var str = JSON.stringify(o);
  var obj = JSON.parse(str, function (_, val) {
    if (!val) return val;

    if (val.type && val.type === 'Set') {
      return new Set(val.arr);
    }

    if (val.type && val.type === 'Map') {
      return new Map(Object.entries(val.obj));
    }

    return val;
  });
  return obj;
}

function defaultSerializer(obj) {
  if (!obj) return {};
  var str = JSON.stringify(toJS(obj), function (_, val) {
    if (val instanceof Set) {
      return {
        type: 'Set',
        arr: Array.from(val)
      };
    }

    if (val instanceof Map) {
      return {
        type: 'Map',
        obj: Object.fromEntries(val)
      };
    }

    return val;
  });
  return JSON.parse(str);
}

function generateTimeStamp() {
  return new Date().getTime();
}

function differ(obj1, obj2) {
  return diff(obj1, obj2);
}

/* eslint-disable no-bitwise */
function generateUUID() {
  var d = new Date().getTime();
  d += new Date().valueOf();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
}

function createProvenanceGraph(state) {
  var _nodes;

  var root = {
    id: generateUUID(),
    label: 'Root',
    metadata: {
      createdOn: generateTimeStamp(),
      eventType: 'Root'
    },
    children: [],
    state: state,
    actionType: 'Regular',
    bookmarked: false
  };
  var graph = {
    nodes: (_nodes = {}, _nodes[root.id] = root, _nodes),
    root: root.id,
    current: root.id
  };
  return graph;
}

function createNewStateNode(parent, state, label, actionType, eventType, meta) {
  return {
    id: generateUUID(),
    label: label,
    metadata: _extends({
      createdOn: generateTimeStamp(),
      eventType: eventType
    }, meta),
    artifacts: {
      annotations: [],
      customArtifacts: []
    },
    parent: parent,
    children: [],
    state: state,
    actionType: actionType,
    bookmarked: false
  };
}

function createNewDiffNode(parent, label, diffs, actionType, previousStateId, eventType, meta) {
  return {
    id: generateUUID(),
    label: label,
    metadata: _extends({
      createdOn: generateTimeStamp(),
      eventType: eventType
    }, meta),
    artifacts: {
      annotations: [],
      customArtifacts: []
    },
    parent: parent,
    children: [],
    lastStateNode: previousStateId,
    diffs: diffs,
    actionType: actionType,
    bookmarked: false
  };
} // export const updateMobxObservable = action(<T>(oldObject: T, newObject: T) => {
//   Object.keys(oldObject).forEach((k) => {
//     const key: Extract<keyof T, string> = k as any;
//     const oldValue = oldObject[key];
//     const newValue = newObject[key];
//     if (newValue !== oldValue) {
//       let val = newObject[key];
//       val = (typeof val).toString() === 'object' ? observable(val) : val;
//       oldObject[key] = val;
//     }
//   });
// });


var goToNode = /*#__PURE__*/action(function (graph, id) {
  var newCurrentNode = graph.nodes[id];
  if (!newCurrentNode) throw new Error("Node with id: " + id + " does not exist");
  graph.current = newCurrentNode.id;
});
var applyActionFunction = /*#__PURE__*/action(function (_graph, actionFn, currentState, // eslint-disable-next-line no-unused-vars
serialize, customLabel) {
  var graph = _graph;
  var currentId = graph.current;
  var currentNode = graph.nodes[currentId];
  var previousState = null;
  var previousStateID = null;

  if (isDiffNode(currentNode)) {
    previousState = getState(graph, graph.nodes[currentNode.lastStateNode]);
    previousStateID = currentNode.lastStateNode;
  } else {
    previousState = getState(graph, currentNode);
    previousStateID = currentNode.id;
  }

  var saveDiff = isChildNode(currentNode);

  var _actionFn$apply = actionFn.apply(currentState, customLabel),
      state = _actionFn$apply.state,
      stateSaveMode = _actionFn$apply.stateSaveMode,
      actionType = _actionFn$apply.actionType,
      label = _actionFn$apply.label,
      eventType = _actionFn$apply.eventType,
      meta = _actionFn$apply.meta;

  var parentId = graph.current;
  var serializedState = serialize(state);
  var diffs = differ(previousState, serializedState) || [];

  if (saveDiff && Object.keys(previousState).length / 2 < diffs.length) {
    saveDiff = false;
  }

  saveDiff = saveDiff && stateSaveMode === 'Diff';
  var newNode = saveDiff ? createNewDiffNode(parentId, label, diffs, actionType, previousStateID, eventType, meta) : createNewStateNode(parentId, serializedState, label, actionType, eventType, meta);
  graph.nodes[newNode.id] = newNode;
  graph.nodes[currentId].children.push(newNode.id);
  graph.current = newNode.id;
  return graph.nodes[graph.current]; // End
});
var importState = /*#__PURE__*/action(function (graph, importedState) {
  var newNode = createNewStateNode(graph.current, importedState, 'Import', 'Regular', null, {});
  graph.nodes[newNode.id] = newNode;
  graph.current = newNode.id;
});

configure({
  enforceActions: 'always',
  isolateGlobalState: true
});
var PROVSTATEKEY = 'provState';

function createStore(initState, serializer) {
  var obs = makeAutoObservable(createProvenanceGraph(serializer(initState)));
  return obs;
}
/**
 * @template T Represents the given state of an application as defined in initProvenance.
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 * @template A Represents the given "extra" type for storing metadata.
 * Extra is a way to store customized metadata.
 * @param initialState: Initial state for the provenance graph to be created in.
 *  State of the root node.
 * @param _opts: Specify whether or not to loadFromUrl, or utilize firebase integration.
 */


function initProvenance(initialState, _opts) {
  if (_opts === void 0) {
    _opts = {};
  }

  var opts = _extends({
    loadFromUrl: false,
    firebaseConfig: null,
    _serializer: undefined,
    _deserializer: undefined
  }, _opts);

  var setupFinished = false;
  var loadFromUrl = opts.loadFromUrl,
      _serializer = opts._serializer,
      _deserializer = opts._deserializer;
  var serializer = _serializer !== undefined ? _serializer : defaultSerializer;
  var deserializer = _deserializer !== undefined ? _deserializer : defaultDeserializer;
  var graph = createStore(initialState, serializer);
  var state = computed(function () {
    return deserializer(getState(graph, graph.nodes[graph.current]));
  });
  if (loadFromUrl) reaction(function () {
    return state.get();
  }, function (state) {
    var url = new URL(window.location.href);
    var params = new URLSearchParams(url.search);
    var stateEncodedString = compressToEncodedURIComponent(JSON.stringify(serializer(state)));
    params.set(PROVSTATEKEY, stateEncodedString);
    window.history.replaceState({}, '', url.pathname + "?" + params);
  });
  return {
    get state() {
      return state.get();
    },

    get config() {
      return opts;
    },

    get graph() {
      return graph;
    },

    get current() {
      return graph.nodes[graph.current];
    },

    get root() {
      return graph.nodes[graph.root];
    },

    get usingDefaultSerializer() {
      return _serializer === undefined && _deserializer === undefined;
    },

    apply: function apply(action, label) {
      if (!setupFinished) throw new Error('Provenance setup not finished. Please call done function on provenance object after setting up any observers.)');
      applyActionFunction(graph, action, state.get(), serializer, label); // ! Add firebase
    },
    addGlobalObserver: function addGlobalObserver(observer) {
      reaction(function () {
        return toJS(graph);
      }, function (currentGraph, previousGraph) {
        var change = 'Any';
        if (Object.keys(currentGraph.nodes).length > Object.keys(previousGraph.nodes).length) change = 'NodeAdded';else if (currentGraph.current !== previousGraph.current) change = 'CurrentChanged';
        observer(currentGraph, change);
      });
    },
    addObserver: function addObserver(expression, effect) {
      reaction(function () {
        return expression(state.get());
      }, function (current, previous) {
        return effect(current, previous);
      });
    },
    goToNode: function goToNode$1(id) {
      goToNode(graph, id);
    },
    addArtifact: action('Add Artifact Action', function (artifact, _id) {
      var id = graph.current;
      if (_id) id = _id;
      var node = graph.nodes[id];

      if (isChildNode(node)) {
        node.artifacts.customArtifacts.push({
          timestamp: generateTimeStamp(),
          artifact: artifact
        });
      }
    }),
    addAnnotation: action('Add Annotation Action', function (annotation, _id) {
      var id = graph.current;
      if (_id) id = _id;
      var node = graph.nodes[id];

      if (isChildNode(node)) {
        node.artifacts.annotations.push({
          timestamp: generateTimeStamp(),
          annotation: annotation
        });
      }
    }),
    getAllArtifacts: function getAllArtifacts(_id) {
      var id = graph.current;
      if (_id) id = _id;
      var node = graph.nodes[id];

      if (isChildNode(node)) {
        return toJS(node.artifacts.customArtifacts);
      }

      return [];
    },
    getLatestArtifact: function getLatestArtifact(_id) {
      var id = graph.current;
      if (_id) id = _id;
      var node = graph.nodes[id];

      if (isChildNode(node)) {
        var arts = node.artifacts.customArtifacts;
        return toJS(arts[arts.length - 1]);
      }

      return null;
    },
    getAllAnnotation: function getAllAnnotation(_id) {
      var id = graph.current;
      if (_id) id = _id;
      var node = graph.nodes[id];

      if (isChildNode(node)) {
        return toJS(node.artifacts.annotations);
      }

      return [];
    },
    getLatestAnnotation: function getLatestAnnotation(_id) {
      var id = graph.current;
      if (_id) id = _id;
      var node = graph.nodes[id];

      if (isChildNode(node)) {
        var annotations = node.artifacts.annotations;
        return toJS(annotations[annotations.length - 1]);
      }

      return null;
    },
    undo: function undo() {
      var current = this.current;
      if (!isChildNode(current)) console.warn('Already at Root');else goToNode(graph, current.parent);
    },
    redo: function redo(to) {
      if (to === void 0) {
        to = 'latest';
      }

      var current = this.current;

      if (current.children.length === 0) {
        console.warn('Already at latest node in this branch.');
      } else {
        var id = current.children[current.children.length - 1];
        if (to === 'oldest') id = current.children[0];

        goToNode(graph, id);
      }
    },
    goBackOneStep: function goBackOneStep() {
      this.undo();
    },
    goForwardOneStep: function goForwardOneStep(to) {
      if (to === void 0) {
        to = 'latest';
      }

      this.redo(to);
    },
    undoNonEphemeral: function undoNonEphemeral() {
      this.goBackToNonEphemeral();
    },
    goBackToNonEphemeral: function goBackToNonEphemeral() {
      var parent = null;
      var current = graph.nodes[graph.current];

      if (isChildNode(current)) {
        parent = current.parent;

        while (graph.nodes[parent].actionType === 'Ephemeral') {
          var parentNode = graph.nodes[parent];
          if (!isChildNode(parentNode)) break;
          parent = parentNode.parent;
        }

        goToNode(graph, parent);
      }
    },
    redoNonEphemeral: function redoNonEphemeral(to) {
      if (to === void 0) {
        to = 'latest';
      }

      this.goForwardToNonEphemeral(to);
    },
    goForwardToNonEphemeral: function goForwardToNonEphemeral(to) {
      if (to === void 0) {
        to = 'latest';
      }

      var child = null;
      var current = graph.nodes[graph.current];

      if (current.children.length === 0) {
        throw new Error('Already at latest node.');
      }

      child = current.children[to === 'latest' ? current.children.length - 1 : 0];

      while (graph.nodes[child].actionType === 'Ephemeral') {
        var childNode = graph.nodes[child];
        if (childNode.children.length === 0) break;
        child = childNode.children[to === 'latest' ? childNode.children.length - 1 : 0];
      }

      goToNode(graph, child);
    },
    reset: function reset() {
      goToNode(graph, graph.root);
    },
    setBookmark: action('Bookmark Action', function (id, bookmark) {
      graph.nodes[id].bookmarked = bookmark;
    }),
    getBookmark: function getBookmark(id) {
      return graph.nodes[id].bookmarked;
    },
    getAllBookmarks: function getAllBookmarks() {
      return Object.entries(graph.nodes).filter(function (entry) {
        return entry[1].bookmarked;
      }).map(function (d) {
        return d[0];
      });
    },
    exportState: function exportState(partial) {
      if (partial === void 0) {
        partial = false;
      }

      var exportedState = {};

      var currentState = getState(graph, this.current);

      var initState = serializer(initialState);

      if (partial) {
        Object.keys(initState).forEach(function (k) {
          var prev = initState[k];
          var curr = currentState[k];

          if (JSON.stringify(prev) !== JSON.stringify(curr)) {
            var _extends2;

            exportedState = _extends({}, exportedState, (_extends2 = {}, _extends2[k] = currentState[k], _extends2));
          }
        });
      } else {
        exportedState = currentState;
      }

      var compressedString = compressToEncodedURIComponent(JSON.stringify(exportedState));
      return compressedString;
    },
    importState: function importState$1(s) {
      var state;

      if (typeof s === 'string') {
        state = JSON.parse(decompressFromEncodedURIComponent(s) || '{}');
      } else {
        state = _extends({}, this.state, s);
      }

      importState(graph, state);
    },
    exportProvenanceGraph: function exportProvenanceGraph() {
      return JSON.stringify(toJS(graph));
    },
    importProvenanceGraph: action('Import Provenance Graph', function (g) {
      var importedGraph;
      if (typeof g === 'string') importedGraph = JSON.parse(g);else importedGraph = g;
      graph.current = importedGraph.current;
      graph.root = importedGraph.root;
      graph.nodes = importedGraph.nodes;
    }),
    getState: function getState$1(node) {
      var n;

      if (typeof node === 'string') {
        n = graph.nodes[node];
      } else {
        n = node;
      }

      return deserializer(getState(graph, n));
    },
    done: function done() {
      setupFinished = true;

      if (loadFromUrl) {
        var _window, _window$location;

        if (!((_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href)) throw new Error('loadFromUrl option can only be used in a browser environment');
        var url = new URL(window.location.href);
        var params = new URLSearchParams(url.search);
        var importString = params.get(PROVSTATEKEY);
        if (!importString) return;
        this.importState(importString);
      }
    }
  };
}

/* eslint-disable func-names */
/**
 *
 * @template T State of the application
 * @template S Represents the given event types in your application.
 * Event types are used to differentiate between different actions that create nodes.
 *
 * @param func Defines the function which will be executed on provenance apply
 *
 */
// TODO:: Switch Args and S here.

function createAction(func) {
  var _label;

  var _actionType = 'Regular';
  var _stateSaveMode = 'Diff';

  var _eventType;

  var _meta = {};

  var actionObject = function actionObject() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return {
      apply: action(function (state, label) {
        if (!_label) throw new Error('Please specify a default label when you create the action');
        if (!label) label = _label;
        func.apply(void 0, [state].concat(args));
        return {
          state: toJS(state),
          label: label,
          stateSaveMode: _stateSaveMode,
          actionType: _actionType,
          eventType: _eventType,
          meta: _meta
        };
      })
    };
  };

  actionObject.setLabel = function (label) {
    _label = label;
    return this;
  };

  actionObject.setActionType = function (actionType) {
    _actionType = actionType;
    return this;
  };

  actionObject.saveStateMode = function (mode) {
    _stateSaveMode = mode;
    return this;
  };

  actionObject.setEventType = function (evtType) {
    _eventType = evtType;
    return this;
  };

  actionObject.setMetaData = function (m) {
    _meta = m;
    return this;
  };

  return actionObject;
}

export { createAction, getState, initProvenance, isChildNode, isStateNode };
//# sourceMappingURL=trrack.esm.js.map
